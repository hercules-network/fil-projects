// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `response.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilAddPieceResponse {
    // message fields
    pub SectorId: u64,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilAddPieceResponse {
    fn default() -> &'a FilAddPieceResponse {
        <FilAddPieceResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilAddPieceResponse {
    pub fn new() -> FilAddPieceResponse {
        ::std::default::Default::default()
    }

    // uint64 SectorId = 1;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }

    // .FilResponseStatus Status = 2;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilAddPieceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(2, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorId != 0 {
            os.write_uint64(1, self.SectorId)?;
        }
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(2, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilAddPieceResponse {
        FilAddPieceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilAddPieceResponse| { &m.SectorId },
                    |m: &mut FilAddPieceResponse| { &mut m.SectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilAddPieceResponse| { &m.Status },
                    |m: &mut FilAddPieceResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilAddPieceResponse| { &m.ErrorMsg },
                    |m: &mut FilAddPieceResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilAddPieceResponse>(
                    "FilAddPieceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilAddPieceResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilAddPieceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilAddPieceResponse,
        };
        unsafe {
            instance.get(FilAddPieceResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilAddPieceResponse {
    fn clear(&mut self) {
        self.SectorId = 0;
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilAddPieceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilAddPieceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetMaxUserBytesPerStagedSectorResponse {
    // message fields
    pub SectorSize: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetMaxUserBytesPerStagedSectorResponse {
    fn default() -> &'a FilGetMaxUserBytesPerStagedSectorResponse {
        <FilGetMaxUserBytesPerStagedSectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGetMaxUserBytesPerStagedSectorResponse {
    pub fn new() -> FilGetMaxUserBytesPerStagedSectorResponse {
        ::std::default::Default::default()
    }

    // uint64 SectorSize = 1;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }
}

impl ::protobuf::Message for FilGetMaxUserBytesPerStagedSectorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorSize != 0 {
            os.write_uint64(1, self.SectorSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetMaxUserBytesPerStagedSectorResponse {
        FilGetMaxUserBytesPerStagedSectorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilGetMaxUserBytesPerStagedSectorResponse| { &m.SectorSize },
                    |m: &mut FilGetMaxUserBytesPerStagedSectorResponse| { &mut m.SectorSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetMaxUserBytesPerStagedSectorResponse>(
                    "FilGetMaxUserBytesPerStagedSectorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetMaxUserBytesPerStagedSectorResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGetMaxUserBytesPerStagedSectorResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetMaxUserBytesPerStagedSectorResponse,
        };
        unsafe {
            instance.get(FilGetMaxUserBytesPerStagedSectorResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGetMaxUserBytesPerStagedSectorResponse {
    fn clear(&mut self) {
        self.SectorSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetMaxUserBytesPerStagedSectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetMaxUserBytesPerStagedSectorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilPieceMetadata {
    // message fields
    pub PieceKey: ::std::string::String,
    pub NumBytes: u64,
    pub CommP: ::std::vec::Vec<u8>,
    pub PieceInclusionProof: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilPieceMetadata {
    fn default() -> &'a FilPieceMetadata {
        <FilPieceMetadata as ::protobuf::Message>::default_instance()
    }
}

impl FilPieceMetadata {
    pub fn new() -> FilPieceMetadata {
        ::std::default::Default::default()
    }

    // string PieceKey = 1;


    pub fn get_PieceKey(&self) -> &str {
        &self.PieceKey
    }
    pub fn clear_PieceKey(&mut self) {
        self.PieceKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceKey(&mut self, v: ::std::string::String) {
        self.PieceKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PieceKey(&mut self) -> &mut ::std::string::String {
        &mut self.PieceKey
    }

    // Take field
    pub fn take_PieceKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PieceKey, ::std::string::String::new())
    }

    // uint64 NumBytes = 2;


    pub fn get_NumBytes(&self) -> u64 {
        self.NumBytes
    }
    pub fn clear_NumBytes(&mut self) {
        self.NumBytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_NumBytes(&mut self, v: u64) {
        self.NumBytes = v;
    }

    // bytes CommP = 3;


    pub fn get_CommP(&self) -> &[u8] {
        &self.CommP
    }
    pub fn clear_CommP(&mut self) {
        self.CommP.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommP(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommP = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommP(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommP
    }

    // Take field
    pub fn take_CommP(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommP, ::std::vec::Vec::new())
    }

    // bytes PieceInclusionProof = 4;


    pub fn get_PieceInclusionProof(&self) -> &[u8] {
        &self.PieceInclusionProof
    }
    pub fn clear_PieceInclusionProof(&mut self) {
        self.PieceInclusionProof.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceInclusionProof(&mut self, v: ::std::vec::Vec<u8>) {
        self.PieceInclusionProof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PieceInclusionProof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.PieceInclusionProof
    }

    // Take field
    pub fn take_PieceInclusionProof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.PieceInclusionProof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilPieceMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PieceKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.NumBytes = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommP)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.PieceInclusionProof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PieceKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PieceKey);
        }
        if self.NumBytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.NumBytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.CommP.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.CommP);
        }
        if !self.PieceInclusionProof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.PieceInclusionProof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PieceKey.is_empty() {
            os.write_string(1, &self.PieceKey)?;
        }
        if self.NumBytes != 0 {
            os.write_uint64(2, self.NumBytes)?;
        }
        if !self.CommP.is_empty() {
            os.write_bytes(3, &self.CommP)?;
        }
        if !self.PieceInclusionProof.is_empty() {
            os.write_bytes(4, &self.PieceInclusionProof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilPieceMetadata {
        FilPieceMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PieceKey",
                    |m: &FilPieceMetadata| { &m.PieceKey },
                    |m: &mut FilPieceMetadata| { &mut m.PieceKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "NumBytes",
                    |m: &FilPieceMetadata| { &m.NumBytes },
                    |m: &mut FilPieceMetadata| { &mut m.NumBytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommP",
                    |m: &FilPieceMetadata| { &m.CommP },
                    |m: &mut FilPieceMetadata| { &mut m.CommP },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "PieceInclusionProof",
                    |m: &FilPieceMetadata| { &m.PieceInclusionProof },
                    |m: &mut FilPieceMetadata| { &mut m.PieceInclusionProof },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilPieceMetadata>(
                    "FilPieceMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilPieceMetadata {
        static mut instance: ::protobuf::lazy::Lazy<FilPieceMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilPieceMetadata,
        };
        unsafe {
            instance.get(FilPieceMetadata::new)
        }
    }
}

impl ::protobuf::Clear for FilPieceMetadata {
    fn clear(&mut self) {
        self.PieceKey.clear();
        self.NumBytes = 0;
        self.CommP.clear();
        self.PieceInclusionProof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilPieceMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilPieceMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSealedSectorMetadata {
    // message fields
    pub SectorId: u64,
    pub SectorAccess: ::std::string::String,
    pub Pieces: ::protobuf::RepeatedField<FilPieceMetadata>,
    pub CommRs: ::std::vec::Vec<u8>,
    pub CommR: ::std::vec::Vec<u8>,
    pub CommD: ::std::vec::Vec<u8>,
    pub Proof: ::std::vec::Vec<u8>,
    pub SealedData: ::std::vec::Vec<u8>,
    pub Health: FilSealedSectorHealth,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSealedSectorMetadata {
    fn default() -> &'a FilSealedSectorMetadata {
        <FilSealedSectorMetadata as ::protobuf::Message>::default_instance()
    }
}

impl FilSealedSectorMetadata {
    pub fn new() -> FilSealedSectorMetadata {
        ::std::default::Default::default()
    }

    // uint64 SectorId = 1;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }

    // string SectorAccess = 2;


    pub fn get_SectorAccess(&self) -> &str {
        &self.SectorAccess
    }
    pub fn clear_SectorAccess(&mut self) {
        self.SectorAccess.clear();
    }

    // Param is passed by value, moved
    pub fn set_SectorAccess(&mut self, v: ::std::string::String) {
        self.SectorAccess = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SectorAccess(&mut self) -> &mut ::std::string::String {
        &mut self.SectorAccess
    }

    // Take field
    pub fn take_SectorAccess(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SectorAccess, ::std::string::String::new())
    }

    // repeated .FilPieceMetadata Pieces = 3;


    pub fn get_Pieces(&self) -> &[FilPieceMetadata] {
        &self.Pieces
    }
    pub fn clear_Pieces(&mut self) {
        self.Pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Pieces(&mut self, v: ::protobuf::RepeatedField<FilPieceMetadata>) {
        self.Pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Pieces(&mut self) -> &mut ::protobuf::RepeatedField<FilPieceMetadata> {
        &mut self.Pieces
    }

    // Take field
    pub fn take_Pieces(&mut self) -> ::protobuf::RepeatedField<FilPieceMetadata> {
        ::std::mem::replace(&mut self.Pieces, ::protobuf::RepeatedField::new())
    }

    // bytes CommRs = 4;


    pub fn get_CommRs(&self) -> &[u8] {
        &self.CommRs
    }
    pub fn clear_CommRs(&mut self) {
        self.CommRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommRs(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommRs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommRs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommRs
    }

    // Take field
    pub fn take_CommRs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommRs, ::std::vec::Vec::new())
    }

    // bytes CommR = 5;


    pub fn get_CommR(&self) -> &[u8] {
        &self.CommR
    }
    pub fn clear_CommR(&mut self) {
        self.CommR.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommR(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommR = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommR(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommR
    }

    // Take field
    pub fn take_CommR(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommR, ::std::vec::Vec::new())
    }

    // bytes CommD = 6;


    pub fn get_CommD(&self) -> &[u8] {
        &self.CommD
    }
    pub fn clear_CommD(&mut self) {
        self.CommD.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommD(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommD = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommD(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommD
    }

    // Take field
    pub fn take_CommD(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommD, ::std::vec::Vec::new())
    }

    // bytes Proof = 7;


    pub fn get_Proof(&self) -> &[u8] {
        &self.Proof
    }
    pub fn clear_Proof(&mut self) {
        self.Proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_Proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.Proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Proof
    }

    // Take field
    pub fn take_Proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Proof, ::std::vec::Vec::new())
    }

    // bytes SealedData = 8;


    pub fn get_SealedData(&self) -> &[u8] {
        &self.SealedData
    }
    pub fn clear_SealedData(&mut self) {
        self.SealedData.clear();
    }

    // Param is passed by value, moved
    pub fn set_SealedData(&mut self, v: ::std::vec::Vec<u8>) {
        self.SealedData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SealedData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.SealedData
    }

    // Take field
    pub fn take_SealedData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.SealedData, ::std::vec::Vec::new())
    }

    // .FilSealedSectorHealth Health = 9;


    pub fn get_Health(&self) -> FilSealedSectorHealth {
        self.Health
    }
    pub fn clear_Health(&mut self) {
        self.Health = FilSealedSectorHealth::Unknown;
    }

    // Param is passed by value, moved
    pub fn set_Health(&mut self, v: FilSealedSectorHealth) {
        self.Health = v;
    }
}

impl ::protobuf::Message for FilSealedSectorMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.Pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SectorAccess)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Pieces)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommRs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommR)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommD)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Proof)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.SealedData)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Health, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SectorAccess.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SectorAccess);
        }
        for value in &self.Pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.CommRs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.CommRs);
        }
        if !self.CommR.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.CommR);
        }
        if !self.CommD.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.CommD);
        }
        if !self.Proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.Proof);
        }
        if !self.SealedData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.SealedData);
        }
        if self.Health != FilSealedSectorHealth::Unknown {
            my_size += ::protobuf::rt::enum_size(9, self.Health);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorId != 0 {
            os.write_uint64(1, self.SectorId)?;
        }
        if !self.SectorAccess.is_empty() {
            os.write_string(2, &self.SectorAccess)?;
        }
        for v in &self.Pieces {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.CommRs.is_empty() {
            os.write_bytes(4, &self.CommRs)?;
        }
        if !self.CommR.is_empty() {
            os.write_bytes(5, &self.CommR)?;
        }
        if !self.CommD.is_empty() {
            os.write_bytes(6, &self.CommD)?;
        }
        if !self.Proof.is_empty() {
            os.write_bytes(7, &self.Proof)?;
        }
        if !self.SealedData.is_empty() {
            os.write_bytes(8, &self.SealedData)?;
        }
        if self.Health != FilSealedSectorHealth::Unknown {
            os.write_enum(9, self.Health.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSealedSectorMetadata {
        FilSealedSectorMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilSealedSectorMetadata| { &m.SectorId },
                    |m: &mut FilSealedSectorMetadata| { &mut m.SectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SectorAccess",
                    |m: &FilSealedSectorMetadata| { &m.SectorAccess },
                    |m: &mut FilSealedSectorMetadata| { &mut m.SectorAccess },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilPieceMetadata>>(
                    "Pieces",
                    |m: &FilSealedSectorMetadata| { &m.Pieces },
                    |m: &mut FilSealedSectorMetadata| { &mut m.Pieces },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommRs",
                    |m: &FilSealedSectorMetadata| { &m.CommRs },
                    |m: &mut FilSealedSectorMetadata| { &mut m.CommRs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommR",
                    |m: &FilSealedSectorMetadata| { &m.CommR },
                    |m: &mut FilSealedSectorMetadata| { &mut m.CommR },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommD",
                    |m: &FilSealedSectorMetadata| { &m.CommD },
                    |m: &mut FilSealedSectorMetadata| { &mut m.CommD },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Proof",
                    |m: &FilSealedSectorMetadata| { &m.Proof },
                    |m: &mut FilSealedSectorMetadata| { &mut m.Proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "SealedData",
                    |m: &FilSealedSectorMetadata| { &m.SealedData },
                    |m: &mut FilSealedSectorMetadata| { &mut m.SealedData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilSealedSectorHealth>>(
                    "Health",
                    |m: &FilSealedSectorMetadata| { &m.Health },
                    |m: &mut FilSealedSectorMetadata| { &mut m.Health },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSealedSectorMetadata>(
                    "FilSealedSectorMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSealedSectorMetadata {
        static mut instance: ::protobuf::lazy::Lazy<FilSealedSectorMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSealedSectorMetadata,
        };
        unsafe {
            instance.get(FilSealedSectorMetadata::new)
        }
    }
}

impl ::protobuf::Clear for FilSealedSectorMetadata {
    fn clear(&mut self) {
        self.SectorId = 0;
        self.SectorAccess.clear();
        self.Pieces.clear();
        self.CommRs.clear();
        self.CommR.clear();
        self.CommD.clear();
        self.Proof.clear();
        self.SealedData.clear();
        self.Health = FilSealedSectorHealth::Unknown;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSealedSectorMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealedSectorMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilStagedSectorMetadata {
    // message fields
    pub SectorId: u64,
    pub SectorAccess: ::std::string::String,
    pub Pieces: ::protobuf::RepeatedField<FilPieceMetadata>,
    pub Status: FilSealStatus,
    pub StagedData: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilStagedSectorMetadata {
    fn default() -> &'a FilStagedSectorMetadata {
        <FilStagedSectorMetadata as ::protobuf::Message>::default_instance()
    }
}

impl FilStagedSectorMetadata {
    pub fn new() -> FilStagedSectorMetadata {
        ::std::default::Default::default()
    }

    // uint64 SectorId = 1;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }

    // string SectorAccess = 2;


    pub fn get_SectorAccess(&self) -> &str {
        &self.SectorAccess
    }
    pub fn clear_SectorAccess(&mut self) {
        self.SectorAccess.clear();
    }

    // Param is passed by value, moved
    pub fn set_SectorAccess(&mut self, v: ::std::string::String) {
        self.SectorAccess = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SectorAccess(&mut self) -> &mut ::std::string::String {
        &mut self.SectorAccess
    }

    // Take field
    pub fn take_SectorAccess(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SectorAccess, ::std::string::String::new())
    }

    // repeated .FilPieceMetadata Pieces = 3;


    pub fn get_Pieces(&self) -> &[FilPieceMetadata] {
        &self.Pieces
    }
    pub fn clear_Pieces(&mut self) {
        self.Pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Pieces(&mut self, v: ::protobuf::RepeatedField<FilPieceMetadata>) {
        self.Pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Pieces(&mut self) -> &mut ::protobuf::RepeatedField<FilPieceMetadata> {
        &mut self.Pieces
    }

    // Take field
    pub fn take_Pieces(&mut self) -> ::protobuf::RepeatedField<FilPieceMetadata> {
        ::std::mem::replace(&mut self.Pieces, ::protobuf::RepeatedField::new())
    }

    // .FilSealStatus Status = 4;


    pub fn get_Status(&self) -> FilSealStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilSealStatus::Sealed;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilSealStatus) {
        self.Status = v;
    }

    // bytes StagedData = 5;


    pub fn get_StagedData(&self) -> &[u8] {
        &self.StagedData
    }
    pub fn clear_StagedData(&mut self) {
        self.StagedData.clear();
    }

    // Param is passed by value, moved
    pub fn set_StagedData(&mut self, v: ::std::vec::Vec<u8>) {
        self.StagedData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_StagedData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.StagedData
    }

    // Take field
    pub fn take_StagedData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.StagedData, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilStagedSectorMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.Pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SectorAccess)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Pieces)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.StagedData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SectorAccess.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SectorAccess);
        }
        for value in &self.Pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.Status != FilSealStatus::Sealed {
            my_size += ::protobuf::rt::enum_size(4, self.Status);
        }
        if !self.StagedData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.StagedData);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorId != 0 {
            os.write_uint64(1, self.SectorId)?;
        }
        if !self.SectorAccess.is_empty() {
            os.write_string(2, &self.SectorAccess)?;
        }
        for v in &self.Pieces {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.Status != FilSealStatus::Sealed {
            os.write_enum(4, self.Status.value())?;
        }
        if !self.StagedData.is_empty() {
            os.write_bytes(5, &self.StagedData)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilStagedSectorMetadata {
        FilStagedSectorMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilStagedSectorMetadata| { &m.SectorId },
                    |m: &mut FilStagedSectorMetadata| { &mut m.SectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SectorAccess",
                    |m: &FilStagedSectorMetadata| { &m.SectorAccess },
                    |m: &mut FilStagedSectorMetadata| { &mut m.SectorAccess },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilPieceMetadata>>(
                    "Pieces",
                    |m: &FilStagedSectorMetadata| { &m.Pieces },
                    |m: &mut FilStagedSectorMetadata| { &mut m.Pieces },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilSealStatus>>(
                    "Status",
                    |m: &FilStagedSectorMetadata| { &m.Status },
                    |m: &mut FilStagedSectorMetadata| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "StagedData",
                    |m: &FilStagedSectorMetadata| { &m.StagedData },
                    |m: &mut FilStagedSectorMetadata| { &mut m.StagedData },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilStagedSectorMetadata>(
                    "FilStagedSectorMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilStagedSectorMetadata {
        static mut instance: ::protobuf::lazy::Lazy<FilStagedSectorMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilStagedSectorMetadata,
        };
        unsafe {
            instance.get(FilStagedSectorMetadata::new)
        }
    }
}

impl ::protobuf::Clear for FilStagedSectorMetadata {
    fn clear(&mut self) {
        self.SectorId = 0;
        self.SectorAccess.clear();
        self.Pieces.clear();
        self.Status = FilSealStatus::Sealed;
        self.StagedData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilStagedSectorMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilStagedSectorMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetSealStatusResponse {
    // message fields
    pub SealMetaData: ::protobuf::SingularPtrField<FilSealedSectorMetadata>,
    pub SealStatus: FilSealStatus,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetSealStatusResponse {
    fn default() -> &'a FilGetSealStatusResponse {
        <FilGetSealStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGetSealStatusResponse {
    pub fn new() -> FilGetSealStatusResponse {
        ::std::default::Default::default()
    }

    // .FilSealedSectorMetadata SealMetaData = 1;


    pub fn get_SealMetaData(&self) -> &FilSealedSectorMetadata {
        self.SealMetaData.as_ref().unwrap_or_else(|| FilSealedSectorMetadata::default_instance())
    }
    pub fn clear_SealMetaData(&mut self) {
        self.SealMetaData.clear();
    }

    pub fn has_SealMetaData(&self) -> bool {
        self.SealMetaData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SealMetaData(&mut self, v: FilSealedSectorMetadata) {
        self.SealMetaData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SealMetaData(&mut self) -> &mut FilSealedSectorMetadata {
        if self.SealMetaData.is_none() {
            self.SealMetaData.set_default();
        }
        self.SealMetaData.as_mut().unwrap()
    }

    // Take field
    pub fn take_SealMetaData(&mut self) -> FilSealedSectorMetadata {
        self.SealMetaData.take().unwrap_or_else(|| FilSealedSectorMetadata::new())
    }

    // .FilSealStatus SealStatus = 2;


    pub fn get_SealStatus(&self) -> FilSealStatus {
        self.SealStatus
    }
    pub fn clear_SealStatus(&mut self) {
        self.SealStatus = FilSealStatus::Sealed;
    }

    // Param is passed by value, moved
    pub fn set_SealStatus(&mut self, v: FilSealStatus) {
        self.SealStatus = v;
    }

    // .FilResponseStatus Status = 3;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 4;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilGetSealStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.SealMetaData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SealMetaData)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.SealStatus, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.SealMetaData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.SealStatus != FilSealStatus::Sealed {
            my_size += ::protobuf::rt::enum_size(2, self.SealStatus);
        }
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(3, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.SealMetaData.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.SealStatus != FilSealStatus::Sealed {
            os.write_enum(2, self.SealStatus.value())?;
        }
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(3, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(4, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetSealStatusResponse {
        FilGetSealStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilSealedSectorMetadata>>(
                    "SealMetaData",
                    |m: &FilGetSealStatusResponse| { &m.SealMetaData },
                    |m: &mut FilGetSealStatusResponse| { &mut m.SealMetaData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilSealStatus>>(
                    "SealStatus",
                    |m: &FilGetSealStatusResponse| { &m.SealStatus },
                    |m: &mut FilGetSealStatusResponse| { &mut m.SealStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilGetSealStatusResponse| { &m.Status },
                    |m: &mut FilGetSealStatusResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilGetSealStatusResponse| { &m.ErrorMsg },
                    |m: &mut FilGetSealStatusResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetSealStatusResponse>(
                    "FilGetSealStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetSealStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGetSealStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetSealStatusResponse,
        };
        unsafe {
            instance.get(FilGetSealStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGetSealStatusResponse {
    fn clear(&mut self) {
        self.SealMetaData.clear();
        self.SealStatus = FilSealStatus::Sealed;
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetSealStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetSealStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetSealedSectorsResponse {
    // message fields
    pub MetaData: ::protobuf::RepeatedField<FilSealedSectorMetadata>,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetSealedSectorsResponse {
    fn default() -> &'a FilGetSealedSectorsResponse {
        <FilGetSealedSectorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGetSealedSectorsResponse {
    pub fn new() -> FilGetSealedSectorsResponse {
        ::std::default::Default::default()
    }

    // repeated .FilSealedSectorMetadata MetaData = 1;


    pub fn get_MetaData(&self) -> &[FilSealedSectorMetadata] {
        &self.MetaData
    }
    pub fn clear_MetaData(&mut self) {
        self.MetaData.clear();
    }

    // Param is passed by value, moved
    pub fn set_MetaData(&mut self, v: ::protobuf::RepeatedField<FilSealedSectorMetadata>) {
        self.MetaData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MetaData(&mut self) -> &mut ::protobuf::RepeatedField<FilSealedSectorMetadata> {
        &mut self.MetaData
    }

    // Take field
    pub fn take_MetaData(&mut self) -> ::protobuf::RepeatedField<FilSealedSectorMetadata> {
        ::std::mem::replace(&mut self.MetaData, ::protobuf::RepeatedField::new())
    }

    // .FilResponseStatus Status = 2;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilGetSealedSectorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.MetaData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.MetaData)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.MetaData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(2, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.MetaData {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(2, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetSealedSectorsResponse {
        FilGetSealedSectorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilSealedSectorMetadata>>(
                    "MetaData",
                    |m: &FilGetSealedSectorsResponse| { &m.MetaData },
                    |m: &mut FilGetSealedSectorsResponse| { &mut m.MetaData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilGetSealedSectorsResponse| { &m.Status },
                    |m: &mut FilGetSealedSectorsResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilGetSealedSectorsResponse| { &m.ErrorMsg },
                    |m: &mut FilGetSealedSectorsResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetSealedSectorsResponse>(
                    "FilGetSealedSectorsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetSealedSectorsResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGetSealedSectorsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetSealedSectorsResponse,
        };
        unsafe {
            instance.get(FilGetSealedSectorsResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGetSealedSectorsResponse {
    fn clear(&mut self) {
        self.MetaData.clear();
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetSealedSectorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetSealedSectorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetStagedSectorsResponse {
    // message fields
    pub MetaData: ::protobuf::RepeatedField<FilStagedSectorMetadata>,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetStagedSectorsResponse {
    fn default() -> &'a FilGetStagedSectorsResponse {
        <FilGetStagedSectorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGetStagedSectorsResponse {
    pub fn new() -> FilGetStagedSectorsResponse {
        ::std::default::Default::default()
    }

    // repeated .FilStagedSectorMetadata MetaData = 1;


    pub fn get_MetaData(&self) -> &[FilStagedSectorMetadata] {
        &self.MetaData
    }
    pub fn clear_MetaData(&mut self) {
        self.MetaData.clear();
    }

    // Param is passed by value, moved
    pub fn set_MetaData(&mut self, v: ::protobuf::RepeatedField<FilStagedSectorMetadata>) {
        self.MetaData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MetaData(&mut self) -> &mut ::protobuf::RepeatedField<FilStagedSectorMetadata> {
        &mut self.MetaData
    }

    // Take field
    pub fn take_MetaData(&mut self) -> ::protobuf::RepeatedField<FilStagedSectorMetadata> {
        ::std::mem::replace(&mut self.MetaData, ::protobuf::RepeatedField::new())
    }

    // .FilResponseStatus Status = 2;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilGetStagedSectorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.MetaData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.MetaData)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.MetaData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(2, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.MetaData {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(2, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetStagedSectorsResponse {
        FilGetStagedSectorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilStagedSectorMetadata>>(
                    "MetaData",
                    |m: &FilGetStagedSectorsResponse| { &m.MetaData },
                    |m: &mut FilGetStagedSectorsResponse| { &mut m.MetaData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilGetStagedSectorsResponse| { &m.Status },
                    |m: &mut FilGetStagedSectorsResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilGetStagedSectorsResponse| { &m.ErrorMsg },
                    |m: &mut FilGetStagedSectorsResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetStagedSectorsResponse>(
                    "FilGetStagedSectorsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetStagedSectorsResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGetStagedSectorsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetStagedSectorsResponse,
        };
        unsafe {
            instance.get(FilGetStagedSectorsResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGetStagedSectorsResponse {
    fn clear(&mut self) {
        self.MetaData.clear();
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetStagedSectorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetStagedSectorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGeneratePoStResponse {
    // message fields
    pub Proofs: ::std::vec::Vec<u8>,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGeneratePoStResponse {
    fn default() -> &'a FilGeneratePoStResponse {
        <FilGeneratePoStResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGeneratePoStResponse {
    pub fn new() -> FilGeneratePoStResponse {
        ::std::default::Default::default()
    }

    // bytes Proofs = 1;


    pub fn get_Proofs(&self) -> &[u8] {
        &self.Proofs
    }
    pub fn clear_Proofs(&mut self) {
        self.Proofs.clear();
    }

    // Param is passed by value, moved
    pub fn set_Proofs(&mut self, v: ::std::vec::Vec<u8>) {
        self.Proofs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Proofs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Proofs
    }

    // Take field
    pub fn take_Proofs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Proofs, ::std::vec::Vec::new())
    }

    // .FilResponseStatus Status = 5;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 6;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilGeneratePoStResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Proofs)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Proofs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.Proofs);
        }
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(5, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Proofs.is_empty() {
            os.write_bytes(1, &self.Proofs)?;
        }
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(5, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(6, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGeneratePoStResponse {
        FilGeneratePoStResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Proofs",
                    |m: &FilGeneratePoStResponse| { &m.Proofs },
                    |m: &mut FilGeneratePoStResponse| { &mut m.Proofs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilGeneratePoStResponse| { &m.Status },
                    |m: &mut FilGeneratePoStResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilGeneratePoStResponse| { &m.ErrorMsg },
                    |m: &mut FilGeneratePoStResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGeneratePoStResponse>(
                    "FilGeneratePoStResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGeneratePoStResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGeneratePoStResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGeneratePoStResponse,
        };
        unsafe {
            instance.get(FilGeneratePoStResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGeneratePoStResponse {
    fn clear(&mut self) {
        self.Proofs.clear();
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGeneratePoStResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGeneratePoStResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilInitSectorBuilderResponse {
    // message fields
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilInitSectorBuilderResponse {
    fn default() -> &'a FilInitSectorBuilderResponse {
        <FilInitSectorBuilderResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilInitSectorBuilderResponse {
    pub fn new() -> FilInitSectorBuilderResponse {
        ::std::default::Default::default()
    }

    // .FilResponseStatus Status = 1;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 2;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilInitSectorBuilderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(1, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(1, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(2, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilInitSectorBuilderResponse {
        FilInitSectorBuilderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilInitSectorBuilderResponse| { &m.Status },
                    |m: &mut FilInitSectorBuilderResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilInitSectorBuilderResponse| { &m.ErrorMsg },
                    |m: &mut FilInitSectorBuilderResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilInitSectorBuilderResponse>(
                    "FilInitSectorBuilderResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilInitSectorBuilderResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilInitSectorBuilderResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilInitSectorBuilderResponse,
        };
        unsafe {
            instance.get(FilInitSectorBuilderResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilInitSectorBuilderResponse {
    fn clear(&mut self) {
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilInitSectorBuilderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilInitSectorBuilderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilReadPieceFromSealedSectorResponse {
    // message fields
    pub Data: ::std::vec::Vec<u8>,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilReadPieceFromSealedSectorResponse {
    fn default() -> &'a FilReadPieceFromSealedSectorResponse {
        <FilReadPieceFromSealedSectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilReadPieceFromSealedSectorResponse {
    pub fn new() -> FilReadPieceFromSealedSectorResponse {
        ::std::default::Default::default()
    }

    // bytes Data = 1;


    pub fn get_Data(&self) -> &[u8] {
        &self.Data
    }
    pub fn clear_Data(&mut self) {
        self.Data.clear();
    }

    // Param is passed by value, moved
    pub fn set_Data(&mut self, v: ::std::vec::Vec<u8>) {
        self.Data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Data
    }

    // Take field
    pub fn take_Data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Data, ::std::vec::Vec::new())
    }

    // .FilResponseStatus Status = 2;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilReadPieceFromSealedSectorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Data)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.Data);
        }
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(2, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Data.is_empty() {
            os.write_bytes(1, &self.Data)?;
        }
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(2, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilReadPieceFromSealedSectorResponse {
        FilReadPieceFromSealedSectorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Data",
                    |m: &FilReadPieceFromSealedSectorResponse| { &m.Data },
                    |m: &mut FilReadPieceFromSealedSectorResponse| { &mut m.Data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilReadPieceFromSealedSectorResponse| { &m.Status },
                    |m: &mut FilReadPieceFromSealedSectorResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilReadPieceFromSealedSectorResponse| { &m.ErrorMsg },
                    |m: &mut FilReadPieceFromSealedSectorResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilReadPieceFromSealedSectorResponse>(
                    "FilReadPieceFromSealedSectorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilReadPieceFromSealedSectorResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilReadPieceFromSealedSectorResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilReadPieceFromSealedSectorResponse,
        };
        unsafe {
            instance.get(FilReadPieceFromSealedSectorResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilReadPieceFromSealedSectorResponse {
    fn clear(&mut self) {
        self.Data.clear();
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilReadPieceFromSealedSectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilReadPieceFromSealedSectorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSealAllStagedSectorsResponse {
    // message fields
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSealAllStagedSectorsResponse {
    fn default() -> &'a FilSealAllStagedSectorsResponse {
        <FilSealAllStagedSectorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilSealAllStagedSectorsResponse {
    pub fn new() -> FilSealAllStagedSectorsResponse {
        ::std::default::Default::default()
    }

    // .FilResponseStatus Status = 1;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 2;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilSealAllStagedSectorsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(1, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(1, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(2, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSealAllStagedSectorsResponse {
        FilSealAllStagedSectorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilSealAllStagedSectorsResponse| { &m.Status },
                    |m: &mut FilSealAllStagedSectorsResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilSealAllStagedSectorsResponse| { &m.ErrorMsg },
                    |m: &mut FilSealAllStagedSectorsResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSealAllStagedSectorsResponse>(
                    "FilSealAllStagedSectorsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSealAllStagedSectorsResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilSealAllStagedSectorsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSealAllStagedSectorsResponse,
        };
        unsafe {
            instance.get(FilSealAllStagedSectorsResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilSealAllStagedSectorsResponse {
    fn clear(&mut self) {
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSealAllStagedSectorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealAllStagedSectorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSealResponse {
    // message fields
    pub ProverId: ::std::vec::Vec<u8>,
    pub SectorId: u64,
    pub CommR: ::std::vec::Vec<u8>,
    pub CommRs: ::std::vec::Vec<u8>,
    pub CommD: ::std::vec::Vec<u8>,
    pub Proof: ::std::vec::Vec<u8>,
    pub CommPs: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub Pieces: ::protobuf::RepeatedField<FilPieceMetadata>,
    pub Data: ::std::vec::Vec<u8>,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSealResponse {
    fn default() -> &'a FilSealResponse {
        <FilSealResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilSealResponse {
    pub fn new() -> FilSealResponse {
        ::std::default::Default::default()
    }

    // bytes ProverId = 1;


    pub fn get_ProverId(&self) -> &[u8] {
        &self.ProverId
    }
    pub fn clear_ProverId(&mut self) {
        self.ProverId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProverId(&mut self, v: ::std::vec::Vec<u8>) {
        self.ProverId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProverId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ProverId
    }

    // Take field
    pub fn take_ProverId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ProverId, ::std::vec::Vec::new())
    }

    // uint64 SectorId = 2;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }

    // bytes CommR = 3;


    pub fn get_CommR(&self) -> &[u8] {
        &self.CommR
    }
    pub fn clear_CommR(&mut self) {
        self.CommR.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommR(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommR = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommR(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommR
    }

    // Take field
    pub fn take_CommR(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommR, ::std::vec::Vec::new())
    }

    // bytes CommRs = 4;


    pub fn get_CommRs(&self) -> &[u8] {
        &self.CommRs
    }
    pub fn clear_CommRs(&mut self) {
        self.CommRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommRs(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommRs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommRs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommRs
    }

    // Take field
    pub fn take_CommRs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommRs, ::std::vec::Vec::new())
    }

    // bytes CommD = 5;


    pub fn get_CommD(&self) -> &[u8] {
        &self.CommD
    }
    pub fn clear_CommD(&mut self) {
        self.CommD.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommD(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommD = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommD(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommD
    }

    // Take field
    pub fn take_CommD(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommD, ::std::vec::Vec::new())
    }

    // bytes Proof = 6;


    pub fn get_Proof(&self) -> &[u8] {
        &self.Proof
    }
    pub fn clear_Proof(&mut self) {
        self.Proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_Proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.Proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Proof
    }

    // Take field
    pub fn take_Proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Proof, ::std::vec::Vec::new())
    }

    // repeated bytes CommPs = 7;


    pub fn get_CommPs(&self) -> &[::std::vec::Vec<u8>] {
        &self.CommPs
    }
    pub fn clear_CommPs(&mut self) {
        self.CommPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommPs(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.CommPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CommPs(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.CommPs
    }

    // Take field
    pub fn take_CommPs(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.CommPs, ::protobuf::RepeatedField::new())
    }

    // repeated .FilPieceMetadata Pieces = 8;


    pub fn get_Pieces(&self) -> &[FilPieceMetadata] {
        &self.Pieces
    }
    pub fn clear_Pieces(&mut self) {
        self.Pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Pieces(&mut self, v: ::protobuf::RepeatedField<FilPieceMetadata>) {
        self.Pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Pieces(&mut self) -> &mut ::protobuf::RepeatedField<FilPieceMetadata> {
        &mut self.Pieces
    }

    // Take field
    pub fn take_Pieces(&mut self) -> ::protobuf::RepeatedField<FilPieceMetadata> {
        ::std::mem::replace(&mut self.Pieces, ::protobuf::RepeatedField::new())
    }

    // bytes Data = 9;


    pub fn get_Data(&self) -> &[u8] {
        &self.Data
    }
    pub fn clear_Data(&mut self) {
        self.Data.clear();
    }

    // Param is passed by value, moved
    pub fn set_Data(&mut self, v: ::std::vec::Vec<u8>) {
        self.Data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Data
    }

    // Take field
    pub fn take_Data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Data, ::std::vec::Vec::new())
    }

    // .FilResponseStatus Status = 10;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 11;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilSealResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ProverId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommR)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommRs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommD)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Proof)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.CommPs)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Pieces)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Data)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ProverId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ProverId);
        }
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.CommR.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.CommR);
        }
        if !self.CommRs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.CommRs);
        }
        if !self.CommD.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.CommD);
        }
        if !self.Proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.Proof);
        }
        for value in &self.CommPs {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        for value in &self.Pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.Data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.Data);
        }
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(10, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ProverId.is_empty() {
            os.write_bytes(1, &self.ProverId)?;
        }
        if self.SectorId != 0 {
            os.write_uint64(2, self.SectorId)?;
        }
        if !self.CommR.is_empty() {
            os.write_bytes(3, &self.CommR)?;
        }
        if !self.CommRs.is_empty() {
            os.write_bytes(4, &self.CommRs)?;
        }
        if !self.CommD.is_empty() {
            os.write_bytes(5, &self.CommD)?;
        }
        if !self.Proof.is_empty() {
            os.write_bytes(6, &self.Proof)?;
        }
        for v in &self.CommPs {
            os.write_bytes(7, &v)?;
        };
        for v in &self.Pieces {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.Data.is_empty() {
            os.write_bytes(9, &self.Data)?;
        }
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(10, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(11, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSealResponse {
        FilSealResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ProverId",
                    |m: &FilSealResponse| { &m.ProverId },
                    |m: &mut FilSealResponse| { &mut m.ProverId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilSealResponse| { &m.SectorId },
                    |m: &mut FilSealResponse| { &mut m.SectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommR",
                    |m: &FilSealResponse| { &m.CommR },
                    |m: &mut FilSealResponse| { &mut m.CommR },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommRs",
                    |m: &FilSealResponse| { &m.CommRs },
                    |m: &mut FilSealResponse| { &mut m.CommRs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommD",
                    |m: &FilSealResponse| { &m.CommD },
                    |m: &mut FilSealResponse| { &mut m.CommD },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Proof",
                    |m: &FilSealResponse| { &m.Proof },
                    |m: &mut FilSealResponse| { &mut m.Proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommPs",
                    |m: &FilSealResponse| { &m.CommPs },
                    |m: &mut FilSealResponse| { &mut m.CommPs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilPieceMetadata>>(
                    "Pieces",
                    |m: &FilSealResponse| { &m.Pieces },
                    |m: &mut FilSealResponse| { &mut m.Pieces },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Data",
                    |m: &FilSealResponse| { &m.Data },
                    |m: &mut FilSealResponse| { &mut m.Data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilSealResponse| { &m.Status },
                    |m: &mut FilSealResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilSealResponse| { &m.ErrorMsg },
                    |m: &mut FilSealResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSealResponse>(
                    "FilSealResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSealResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilSealResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSealResponse,
        };
        unsafe {
            instance.get(FilSealResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilSealResponse {
    fn clear(&mut self) {
        self.ProverId.clear();
        self.SectorId = 0;
        self.CommR.clear();
        self.CommRs.clear();
        self.CommD.clear();
        self.Proof.clear();
        self.CommPs.clear();
        self.Pieces.clear();
        self.Data.clear();
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSealResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSealCallBackResponse {
    // message fields
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSealCallBackResponse {
    fn default() -> &'a FilSealCallBackResponse {
        <FilSealCallBackResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilSealCallBackResponse {
    pub fn new() -> FilSealCallBackResponse {
        ::std::default::Default::default()
    }

    // .FilResponseStatus Status = 1;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 2;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilSealCallBackResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(1, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(1, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(2, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSealCallBackResponse {
        FilSealCallBackResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilSealCallBackResponse| { &m.Status },
                    |m: &mut FilSealCallBackResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilSealCallBackResponse| { &m.ErrorMsg },
                    |m: &mut FilSealCallBackResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSealCallBackResponse>(
                    "FilSealCallBackResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSealCallBackResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilSealCallBackResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSealCallBackResponse,
        };
        unsafe {
            instance.get(FilSealCallBackResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilSealCallBackResponse {
    fn clear(&mut self) {
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSealCallBackResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealCallBackResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilVerifyPieceResponse {
    // message fields
    pub IsValid: bool,
    pub Status: u64,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilVerifyPieceResponse {
    fn default() -> &'a FilVerifyPieceResponse {
        <FilVerifyPieceResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilVerifyPieceResponse {
    pub fn new() -> FilVerifyPieceResponse {
        ::std::default::Default::default()
    }

    // bool IsValid = 1;


    pub fn get_IsValid(&self) -> bool {
        self.IsValid
    }
    pub fn clear_IsValid(&mut self) {
        self.IsValid = false;
    }

    // Param is passed by value, moved
    pub fn set_IsValid(&mut self, v: bool) {
        self.IsValid = v;
    }

    // uint64 Status = 2;


    pub fn get_Status(&self) -> u64 {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = 0;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: u64) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilVerifyPieceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.IsValid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Status = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.IsValid != false {
            my_size += 2;
        }
        if self.Status != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Status, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.IsValid != false {
            os.write_bool(1, self.IsValid)?;
        }
        if self.Status != 0 {
            os.write_uint64(2, self.Status)?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilVerifyPieceResponse {
        FilVerifyPieceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "IsValid",
                    |m: &FilVerifyPieceResponse| { &m.IsValid },
                    |m: &mut FilVerifyPieceResponse| { &mut m.IsValid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Status",
                    |m: &FilVerifyPieceResponse| { &m.Status },
                    |m: &mut FilVerifyPieceResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilVerifyPieceResponse| { &m.ErrorMsg },
                    |m: &mut FilVerifyPieceResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilVerifyPieceResponse>(
                    "FilVerifyPieceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilVerifyPieceResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilVerifyPieceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilVerifyPieceResponse,
        };
        unsafe {
            instance.get(FilVerifyPieceResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilVerifyPieceResponse {
    fn clear(&mut self) {
        self.IsValid = false;
        self.Status = 0;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilVerifyPieceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilVerifyPieceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilVerifySealResponse {
    // message fields
    pub IsValid: bool,
    pub Status: u64,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilVerifySealResponse {
    fn default() -> &'a FilVerifySealResponse {
        <FilVerifySealResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilVerifySealResponse {
    pub fn new() -> FilVerifySealResponse {
        ::std::default::Default::default()
    }

    // bool IsValid = 1;


    pub fn get_IsValid(&self) -> bool {
        self.IsValid
    }
    pub fn clear_IsValid(&mut self) {
        self.IsValid = false;
    }

    // Param is passed by value, moved
    pub fn set_IsValid(&mut self, v: bool) {
        self.IsValid = v;
    }

    // uint64 Status = 2;


    pub fn get_Status(&self) -> u64 {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = 0;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: u64) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilVerifySealResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.IsValid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Status = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.IsValid != false {
            my_size += 2;
        }
        if self.Status != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Status, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.IsValid != false {
            os.write_bool(1, self.IsValid)?;
        }
        if self.Status != 0 {
            os.write_uint64(2, self.Status)?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilVerifySealResponse {
        FilVerifySealResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "IsValid",
                    |m: &FilVerifySealResponse| { &m.IsValid },
                    |m: &mut FilVerifySealResponse| { &mut m.IsValid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Status",
                    |m: &FilVerifySealResponse| { &m.Status },
                    |m: &mut FilVerifySealResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilVerifySealResponse| { &m.ErrorMsg },
                    |m: &mut FilVerifySealResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilVerifySealResponse>(
                    "FilVerifySealResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilVerifySealResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilVerifySealResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilVerifySealResponse,
        };
        unsafe {
            instance.get(FilVerifySealResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilVerifySealResponse {
    fn clear(&mut self) {
        self.IsValid = false;
        self.Status = 0;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilVerifySealResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilVerifySealResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilVerifyPoStResponse {
    // message fields
    pub IsValid: bool,
    pub Status: u64,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilVerifyPoStResponse {
    fn default() -> &'a FilVerifyPoStResponse {
        <FilVerifyPoStResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilVerifyPoStResponse {
    pub fn new() -> FilVerifyPoStResponse {
        ::std::default::Default::default()
    }

    // bool IsValid = 1;


    pub fn get_IsValid(&self) -> bool {
        self.IsValid
    }
    pub fn clear_IsValid(&mut self) {
        self.IsValid = false;
    }

    // Param is passed by value, moved
    pub fn set_IsValid(&mut self, v: bool) {
        self.IsValid = v;
    }

    // uint64 Status = 2;


    pub fn get_Status(&self) -> u64 {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = 0;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: u64) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilVerifyPoStResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.IsValid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Status = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.IsValid != false {
            my_size += 2;
        }
        if self.Status != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Status, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.IsValid != false {
            os.write_bool(1, self.IsValid)?;
        }
        if self.Status != 0 {
            os.write_uint64(2, self.Status)?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilVerifyPoStResponse {
        FilVerifyPoStResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "IsValid",
                    |m: &FilVerifyPoStResponse| { &m.IsValid },
                    |m: &mut FilVerifyPoStResponse| { &mut m.IsValid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Status",
                    |m: &FilVerifyPoStResponse| { &m.Status },
                    |m: &mut FilVerifyPoStResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilVerifyPoStResponse| { &m.ErrorMsg },
                    |m: &mut FilVerifyPoStResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilVerifyPoStResponse>(
                    "FilVerifyPoStResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilVerifyPoStResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilVerifyPoStResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilVerifyPoStResponse,
        };
        unsafe {
            instance.get(FilVerifyPoStResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilVerifyPoStResponse {
    fn clear(&mut self) {
        self.IsValid = false;
        self.Status = 0;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilVerifyPoStResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilVerifyPoStResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGeneratePieceCommitentResponse {
    // message fields
    pub Data: ::std::vec::Vec<u8>,
    pub Status: FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGeneratePieceCommitentResponse {
    fn default() -> &'a FilGeneratePieceCommitentResponse {
        <FilGeneratePieceCommitentResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGeneratePieceCommitentResponse {
    pub fn new() -> FilGeneratePieceCommitentResponse {
        ::std::default::Default::default()
    }

    // bytes Data = 1;


    pub fn get_Data(&self) -> &[u8] {
        &self.Data
    }
    pub fn clear_Data(&mut self) {
        self.Data.clear();
    }

    // Param is passed by value, moved
    pub fn set_Data(&mut self, v: ::std::vec::Vec<u8>) {
        self.Data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Data
    }

    // Take field
    pub fn take_Data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Data, ::std::vec::Vec::new())
    }

    // .FilResponseStatus Status = 2;


    pub fn get_Status(&self) -> FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilGeneratePieceCommitentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Data)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.Data);
        }
        if self.Status != FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(2, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Data.is_empty() {
            os.write_bytes(1, &self.Data)?;
        }
        if self.Status != FilResponseStatus::NoError {
            os.write_enum(2, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGeneratePieceCommitentResponse {
        FilGeneratePieceCommitentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Data",
                    |m: &FilGeneratePieceCommitentResponse| { &m.Data },
                    |m: &mut FilGeneratePieceCommitentResponse| { &mut m.Data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilResponseStatus>>(
                    "Status",
                    |m: &FilGeneratePieceCommitentResponse| { &m.Status },
                    |m: &mut FilGeneratePieceCommitentResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilGeneratePieceCommitentResponse| { &m.ErrorMsg },
                    |m: &mut FilGeneratePieceCommitentResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGeneratePieceCommitentResponse>(
                    "FilGeneratePieceCommitentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGeneratePieceCommitentResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGeneratePieceCommitentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGeneratePieceCommitentResponse,
        };
        unsafe {
            instance.get(FilGeneratePieceCommitentResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGeneratePieceCommitentResponse {
    fn clear(&mut self) {
        self.Data.clear();
        self.Status = FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGeneratePieceCommitentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGeneratePieceCommitentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum FilResponseStatus {
    NoError = 0,
    UnclassifiedError = 1,
    CallerError = 2,
    ReceiverError = 3,
}

impl ::protobuf::ProtobufEnum for FilResponseStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FilResponseStatus> {
        match value {
            0 => ::std::option::Option::Some(FilResponseStatus::NoError),
            1 => ::std::option::Option::Some(FilResponseStatus::UnclassifiedError),
            2 => ::std::option::Option::Some(FilResponseStatus::CallerError),
            3 => ::std::option::Option::Some(FilResponseStatus::ReceiverError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FilResponseStatus] = &[
            FilResponseStatus::NoError,
            FilResponseStatus::UnclassifiedError,
            FilResponseStatus::CallerError,
            FilResponseStatus::ReceiverError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FilResponseStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FilResponseStatus {
}

impl ::std::default::Default for FilResponseStatus {
    fn default() -> Self {
        FilResponseStatus::NoError
    }
}

impl ::protobuf::reflect::ProtobufValue for FilResponseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum FilSealStatus {
    Sealed = 0,
    Pending = 1,
    Failed = 2,
    Sealing = 3,
}

impl ::protobuf::ProtobufEnum for FilSealStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FilSealStatus> {
        match value {
            0 => ::std::option::Option::Some(FilSealStatus::Sealed),
            1 => ::std::option::Option::Some(FilSealStatus::Pending),
            2 => ::std::option::Option::Some(FilSealStatus::Failed),
            3 => ::std::option::Option::Some(FilSealStatus::Sealing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FilSealStatus] = &[
            FilSealStatus::Sealed,
            FilSealStatus::Pending,
            FilSealStatus::Failed,
            FilSealStatus::Sealing,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FilSealStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FilSealStatus {
}

impl ::std::default::Default for FilSealStatus {
    fn default() -> Self {
        FilSealStatus::Sealed
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum FilSealedSectorHealth {
    Unknown = 0,
    Ok = 1,
    ErrorInvalidChecksum = 2,
    ErrorInvalidLength = 3,
    ErrorMissing = 4,
}

impl ::protobuf::ProtobufEnum for FilSealedSectorHealth {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FilSealedSectorHealth> {
        match value {
            0 => ::std::option::Option::Some(FilSealedSectorHealth::Unknown),
            1 => ::std::option::Option::Some(FilSealedSectorHealth::Ok),
            2 => ::std::option::Option::Some(FilSealedSectorHealth::ErrorInvalidChecksum),
            3 => ::std::option::Option::Some(FilSealedSectorHealth::ErrorInvalidLength),
            4 => ::std::option::Option::Some(FilSealedSectorHealth::ErrorMissing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FilSealedSectorHealth] = &[
            FilSealedSectorHealth::Unknown,
            FilSealedSectorHealth::Ok,
            FilSealedSectorHealth::ErrorInvalidChecksum,
            FilSealedSectorHealth::ErrorInvalidLength,
            FilSealedSectorHealth::ErrorMissing,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FilSealedSectorHealth", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FilSealedSectorHealth {
}

impl ::std::default::Default for FilSealedSectorHealth {
    fn default() -> Self {
        FilSealedSectorHealth::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealedSectorHealth {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eresponse.proto\x1a\x0frustproto.proto\"y\n\x13FilAddPieceResponse\
    \x12\x1a\n\x08SectorId\x18\x01\x20\x01(\x04R\x08SectorId\x12*\n\x06Statu\
    s\x18\x02\x20\x01(\x0e2\x12.FilResponseStatusR\x06Status\x12\x1a\n\x08Er\
    rorMsg\x18\x03\x20\x01(\tR\x08ErrorMsg\"K\n)FilGetMaxUserBytesPerStagedS\
    ectorResponse\x12\x1e\n\nSectorSize\x18\x01\x20\x01(\x04R\nSectorSize\"\
    \x92\x01\n\x10FilPieceMetadata\x12\x1a\n\x08PieceKey\x18\x01\x20\x01(\tR\
    \x08PieceKey\x12\x1a\n\x08NumBytes\x18\x02\x20\x01(\x04R\x08NumBytes\x12\
    \x14\n\x05CommP\x18\x03\x20\x01(\x0cR\x05CommP\x120\n\x13PieceInclusionP\
    roof\x18\x04\x20\x01(\x0cR\x13PieceInclusionProof\"\xae\x02\n\x17FilSeal\
    edSectorMetadata\x12\x1a\n\x08SectorId\x18\x01\x20\x01(\x04R\x08SectorId\
    \x12\"\n\x0cSectorAccess\x18\x02\x20\x01(\tR\x0cSectorAccess\x12)\n\x06P\
    ieces\x18\x03\x20\x03(\x0b2\x11.FilPieceMetadataR\x06Pieces\x12\x16\n\
    \x06CommRs\x18\x04\x20\x01(\x0cR\x06CommRs\x12\x14\n\x05CommR\x18\x05\
    \x20\x01(\x0cR\x05CommR\x12\x14\n\x05CommD\x18\x06\x20\x01(\x0cR\x05Comm\
    D\x12\x14\n\x05Proof\x18\x07\x20\x01(\x0cR\x05Proof\x12\x1e\n\nSealedDat\
    a\x18\x08\x20\x01(\x0cR\nSealedData\x12.\n\x06Health\x18\t\x20\x01(\x0e2\
    \x16.FilSealedSectorHealthR\x06Health\"\xcc\x01\n\x17FilStagedSectorMeta\
    data\x12\x1a\n\x08SectorId\x18\x01\x20\x01(\x04R\x08SectorId\x12\"\n\x0c\
    SectorAccess\x18\x02\x20\x01(\tR\x0cSectorAccess\x12)\n\x06Pieces\x18\
    \x03\x20\x03(\x0b2\x11.FilPieceMetadataR\x06Pieces\x12&\n\x06Status\x18\
    \x04\x20\x01(\x0e2\x0e.FilSealStatusR\x06Status\x12\x1e\n\nStagedData\
    \x18\x05\x20\x01(\x0cR\nStagedData\"\xd0\x01\n\x18FilGetSealStatusRespon\
    se\x12<\n\x0cSealMetaData\x18\x01\x20\x01(\x0b2\x18.FilSealedSectorMetad\
    ataR\x0cSealMetaData\x12.\n\nSealStatus\x18\x02\x20\x01(\x0e2\x0e.FilSea\
    lStatusR\nSealStatus\x12*\n\x06Status\x18\x03\x20\x01(\x0e2\x12.FilRespo\
    nseStatusR\x06Status\x12\x1a\n\x08ErrorMsg\x18\x04\x20\x01(\tR\x08ErrorM\
    sg\"\x9b\x01\n\x1bFilGetSealedSectorsResponse\x124\n\x08MetaData\x18\x01\
    \x20\x03(\x0b2\x18.FilSealedSectorMetadataR\x08MetaData\x12*\n\x06Status\
    \x18\x02\x20\x01(\x0e2\x12.FilResponseStatusR\x06Status\x12\x1a\n\x08Err\
    orMsg\x18\x03\x20\x01(\tR\x08ErrorMsg\"\x9b\x01\n\x1bFilGetStagedSectors\
    Response\x124\n\x08MetaData\x18\x01\x20\x03(\x0b2\x18.FilStagedSectorMet\
    adataR\x08MetaData\x12*\n\x06Status\x18\x02\x20\x01(\x0e2\x12.FilRespons\
    eStatusR\x06Status\x12\x1a\n\x08ErrorMsg\x18\x03\x20\x01(\tR\x08ErrorMsg\
    \"y\n\x17FilGeneratePoStResponse\x12\x16\n\x06Proofs\x18\x01\x20\x01(\
    \x0cR\x06Proofs\x12*\n\x06Status\x18\x05\x20\x01(\x0e2\x12.FilResponseSt\
    atusR\x06Status\x12\x1a\n\x08ErrorMsg\x18\x06\x20\x01(\tR\x08ErrorMsg\"f\
    \n\x1cFilInitSectorBuilderResponse\x12*\n\x06Status\x18\x01\x20\x01(\x0e\
    2\x12.FilResponseStatusR\x06Status\x12\x1a\n\x08ErrorMsg\x18\x02\x20\x01\
    (\tR\x08ErrorMsg\"\x82\x01\n$FilReadPieceFromSealedSectorResponse\x12\
    \x12\n\x04Data\x18\x01\x20\x01(\x0cR\x04Data\x12*\n\x06Status\x18\x02\
    \x20\x01(\x0e2\x12.FilResponseStatusR\x06Status\x12\x1a\n\x08ErrorMsg\
    \x18\x03\x20\x01(\tR\x08ErrorMsg\"i\n\x1fFilSealAllStagedSectorsResponse\
    \x12*\n\x06Status\x18\x01\x20\x01(\x0e2\x12.FilResponseStatusR\x06Status\
    \x12\x1a\n\x08ErrorMsg\x18\x02\x20\x01(\tR\x08ErrorMsg\"\xc2\x02\n\x0fFi\
    lSealResponse\x12\x1a\n\x08ProverId\x18\x01\x20\x01(\x0cR\x08ProverId\
    \x12\x1a\n\x08SectorId\x18\x02\x20\x01(\x04R\x08SectorId\x12\x14\n\x05Co\
    mmR\x18\x03\x20\x01(\x0cR\x05CommR\x12\x16\n\x06CommRs\x18\x04\x20\x01(\
    \x0cR\x06CommRs\x12\x14\n\x05CommD\x18\x05\x20\x01(\x0cR\x05CommD\x12\
    \x14\n\x05Proof\x18\x06\x20\x01(\x0cR\x05Proof\x12\x16\n\x06CommPs\x18\
    \x07\x20\x03(\x0cR\x06CommPs\x12)\n\x06Pieces\x18\x08\x20\x03(\x0b2\x11.\
    FilPieceMetadataR\x06Pieces\x12\x12\n\x04Data\x18\t\x20\x01(\x0cR\x04Dat\
    a\x12*\n\x06Status\x18\n\x20\x01(\x0e2\x12.FilResponseStatusR\x06Status\
    \x12\x1a\n\x08ErrorMsg\x18\x0b\x20\x01(\tR\x08ErrorMsg\"a\n\x17FilSealCa\
    llBackResponse\x12*\n\x06Status\x18\x01\x20\x01(\x0e2\x12.FilResponseSta\
    tusR\x06Status\x12\x1a\n\x08ErrorMsg\x18\x02\x20\x01(\tR\x08ErrorMsg\"f\
    \n\x16FilVerifyPieceResponse\x12\x18\n\x07IsValid\x18\x01\x20\x01(\x08R\
    \x07IsValid\x12\x16\n\x06Status\x18\x02\x20\x01(\x04R\x06Status\x12\x1a\
    \n\x08ErrorMsg\x18\x03\x20\x01(\tR\x08ErrorMsg\"e\n\x15FilVerifySealResp\
    onse\x12\x18\n\x07IsValid\x18\x01\x20\x01(\x08R\x07IsValid\x12\x16\n\x06\
    Status\x18\x02\x20\x01(\x04R\x06Status\x12\x1a\n\x08ErrorMsg\x18\x03\x20\
    \x01(\tR\x08ErrorMsg\"e\n\x15FilVerifyPoStResponse\x12\x18\n\x07IsValid\
    \x18\x01\x20\x01(\x08R\x07IsValid\x12\x16\n\x06Status\x18\x02\x20\x01(\
    \x04R\x06Status\x12\x1a\n\x08ErrorMsg\x18\x03\x20\x01(\tR\x08ErrorMsg\"\
    \x7f\n!FilGeneratePieceCommitentResponse\x12\x12\n\x04Data\x18\x01\x20\
    \x01(\x0cR\x04Data\x12*\n\x06Status\x18\x02\x20\x01(\x0e2\x12.FilRespons\
    eStatusR\x06Status\x12\x1a\n\x08ErrorMsg\x18\x03\x20\x01(\tR\x08ErrorMsg\
    *[\n\x11FilResponseStatus\x12\x0b\n\x07NoError\x10\0\x12\x15\n\x11Unclas\
    sifiedError\x10\x01\x12\x0f\n\x0bCallerError\x10\x02\x12\x11\n\rReceiver\
    Error\x10\x03*A\n\rFilSealStatus\x12\n\n\x06Sealed\x10\0\x12\x0b\n\x07Pe\
    nding\x10\x01\x12\n\n\x06Failed\x10\x02\x12\x0b\n\x07Sealing\x10\x03*p\n\
    \x15FilSealedSectorHealth\x12\x0b\n\x07Unknown\x10\0\x12\x06\n\x02Ok\x10\
    \x01\x12\x18\n\x14ErrorInvalidChecksum\x10\x02\x12\x16\n\x12ErrorInvalid\
    Length\x10\x03\x12\x10\n\x0cErrorMissing\x10\x04B\x18\xc8\xa6\x08\x01\
    \xe0\xa6\x08\x01\xd8\xa6\x08\x01\xb0\xa8\x08\x01\xe0\xa7\x08\x01\x80\xa8\
    \x08\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
