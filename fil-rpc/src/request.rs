// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `request.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilAddPieceRequest {
    // message fields
    pub PieceKey: ::std::string::String,
    pub PieceBytesAmount: u64,
    pub PiecePath: ::std::string::String,
    pub SecondsSinceEpoch: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilAddPieceRequest {
    fn default() -> &'a FilAddPieceRequest {
        <FilAddPieceRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilAddPieceRequest {
    pub fn new() -> FilAddPieceRequest {
        ::std::default::Default::default()
    }

    // string PieceKey = 1;


    pub fn get_PieceKey(&self) -> &str {
        &self.PieceKey
    }
    pub fn clear_PieceKey(&mut self) {
        self.PieceKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceKey(&mut self, v: ::std::string::String) {
        self.PieceKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PieceKey(&mut self) -> &mut ::std::string::String {
        &mut self.PieceKey
    }

    // Take field
    pub fn take_PieceKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PieceKey, ::std::string::String::new())
    }

    // uint64 PieceBytesAmount = 2;


    pub fn get_PieceBytesAmount(&self) -> u64 {
        self.PieceBytesAmount
    }
    pub fn clear_PieceBytesAmount(&mut self) {
        self.PieceBytesAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_PieceBytesAmount(&mut self, v: u64) {
        self.PieceBytesAmount = v;
    }

    // string PiecePath = 3;


    pub fn get_PiecePath(&self) -> &str {
        &self.PiecePath
    }
    pub fn clear_PiecePath(&mut self) {
        self.PiecePath.clear();
    }

    // Param is passed by value, moved
    pub fn set_PiecePath(&mut self, v: ::std::string::String) {
        self.PiecePath = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PiecePath(&mut self) -> &mut ::std::string::String {
        &mut self.PiecePath
    }

    // Take field
    pub fn take_PiecePath(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PiecePath, ::std::string::String::new())
    }

    // uint64 SecondsSinceEpoch = 4;


    pub fn get_SecondsSinceEpoch(&self) -> u64 {
        self.SecondsSinceEpoch
    }
    pub fn clear_SecondsSinceEpoch(&mut self) {
        self.SecondsSinceEpoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_SecondsSinceEpoch(&mut self, v: u64) {
        self.SecondsSinceEpoch = v;
    }
}

impl ::protobuf::Message for FilAddPieceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PieceKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PieceBytesAmount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PiecePath)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SecondsSinceEpoch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PieceKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PieceKey);
        }
        if self.PieceBytesAmount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.PieceBytesAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.PiecePath.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.PiecePath);
        }
        if self.SecondsSinceEpoch != 0 {
            my_size += ::protobuf::rt::value_size(4, self.SecondsSinceEpoch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PieceKey.is_empty() {
            os.write_string(1, &self.PieceKey)?;
        }
        if self.PieceBytesAmount != 0 {
            os.write_uint64(2, self.PieceBytesAmount)?;
        }
        if !self.PiecePath.is_empty() {
            os.write_string(3, &self.PiecePath)?;
        }
        if self.SecondsSinceEpoch != 0 {
            os.write_uint64(4, self.SecondsSinceEpoch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilAddPieceRequest {
        FilAddPieceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PieceKey",
                    |m: &FilAddPieceRequest| { &m.PieceKey },
                    |m: &mut FilAddPieceRequest| { &mut m.PieceKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PieceBytesAmount",
                    |m: &FilAddPieceRequest| { &m.PieceBytesAmount },
                    |m: &mut FilAddPieceRequest| { &mut m.PieceBytesAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PiecePath",
                    |m: &FilAddPieceRequest| { &m.PiecePath },
                    |m: &mut FilAddPieceRequest| { &mut m.PiecePath },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SecondsSinceEpoch",
                    |m: &FilAddPieceRequest| { &m.SecondsSinceEpoch },
                    |m: &mut FilAddPieceRequest| { &mut m.SecondsSinceEpoch },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilAddPieceRequest>(
                    "FilAddPieceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilAddPieceRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilAddPieceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilAddPieceRequest,
        };
        unsafe {
            instance.get(FilAddPieceRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilAddPieceRequest {
    fn clear(&mut self) {
        self.PieceKey.clear();
        self.PieceBytesAmount = 0;
        self.PiecePath.clear();
        self.SecondsSinceEpoch = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilAddPieceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilAddPieceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilAddPieceExtendRequest {
    // message fields
    pub PieceKey: ::std::string::String,
    pub PieceBytesAmount: u64,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilAddPieceExtendRequest {
    fn default() -> &'a FilAddPieceExtendRequest {
        <FilAddPieceExtendRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilAddPieceExtendRequest {
    pub fn new() -> FilAddPieceExtendRequest {
        ::std::default::Default::default()
    }

    // string PieceKey = 1;


    pub fn get_PieceKey(&self) -> &str {
        &self.PieceKey
    }
    pub fn clear_PieceKey(&mut self) {
        self.PieceKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceKey(&mut self, v: ::std::string::String) {
        self.PieceKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PieceKey(&mut self) -> &mut ::std::string::String {
        &mut self.PieceKey
    }

    // Take field
    pub fn take_PieceKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PieceKey, ::std::string::String::new())
    }

    // uint64 PieceBytesAmount = 2;


    pub fn get_PieceBytesAmount(&self) -> u64 {
        self.PieceBytesAmount
    }
    pub fn clear_PieceBytesAmount(&mut self) {
        self.PieceBytesAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_PieceBytesAmount(&mut self, v: u64) {
        self.PieceBytesAmount = v;
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilAddPieceExtendRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PieceKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PieceBytesAmount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PieceKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PieceKey);
        }
        if self.PieceBytesAmount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.PieceBytesAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PieceKey.is_empty() {
            os.write_string(1, &self.PieceKey)?;
        }
        if self.PieceBytesAmount != 0 {
            os.write_uint64(2, self.PieceBytesAmount)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilAddPieceExtendRequest {
        FilAddPieceExtendRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PieceKey",
                    |m: &FilAddPieceExtendRequest| { &m.PieceKey },
                    |m: &mut FilAddPieceExtendRequest| { &mut m.PieceKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PieceBytesAmount",
                    |m: &FilAddPieceExtendRequest| { &m.PieceBytesAmount },
                    |m: &mut FilAddPieceExtendRequest| { &mut m.PieceBytesAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &FilAddPieceExtendRequest| { &m.data },
                    |m: &mut FilAddPieceExtendRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilAddPieceExtendRequest>(
                    "FilAddPieceExtendRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilAddPieceExtendRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilAddPieceExtendRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilAddPieceExtendRequest,
        };
        unsafe {
            instance.get(FilAddPieceExtendRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilAddPieceExtendRequest {
    fn clear(&mut self) {
        self.PieceKey.clear();
        self.PieceBytesAmount = 0;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilAddPieceExtendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilAddPieceExtendRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetMaxUserBytesPerStagedSectorRequest {
    // message fields
    pub SectorSize: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetMaxUserBytesPerStagedSectorRequest {
    fn default() -> &'a FilGetMaxUserBytesPerStagedSectorRequest {
        <FilGetMaxUserBytesPerStagedSectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilGetMaxUserBytesPerStagedSectorRequest {
    pub fn new() -> FilGetMaxUserBytesPerStagedSectorRequest {
        ::std::default::Default::default()
    }

    // uint64 SectorSize = 1;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }
}

impl ::protobuf::Message for FilGetMaxUserBytesPerStagedSectorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorSize != 0 {
            os.write_uint64(1, self.SectorSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetMaxUserBytesPerStagedSectorRequest {
        FilGetMaxUserBytesPerStagedSectorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilGetMaxUserBytesPerStagedSectorRequest| { &m.SectorSize },
                    |m: &mut FilGetMaxUserBytesPerStagedSectorRequest| { &mut m.SectorSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetMaxUserBytesPerStagedSectorRequest>(
                    "FilGetMaxUserBytesPerStagedSectorRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetMaxUserBytesPerStagedSectorRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilGetMaxUserBytesPerStagedSectorRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetMaxUserBytesPerStagedSectorRequest,
        };
        unsafe {
            instance.get(FilGetMaxUserBytesPerStagedSectorRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilGetMaxUserBytesPerStagedSectorRequest {
    fn clear(&mut self) {
        self.SectorSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetMaxUserBytesPerStagedSectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetMaxUserBytesPerStagedSectorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetSealStatusRequest {
    // message fields
    pub SectorId: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetSealStatusRequest {
    fn default() -> &'a FilGetSealStatusRequest {
        <FilGetSealStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilGetSealStatusRequest {
    pub fn new() -> FilGetSealStatusRequest {
        ::std::default::Default::default()
    }

    // uint64 SectorId = 1;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }
}

impl ::protobuf::Message for FilGetSealStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorId != 0 {
            os.write_uint64(1, self.SectorId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetSealStatusRequest {
        FilGetSealStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilGetSealStatusRequest| { &m.SectorId },
                    |m: &mut FilGetSealStatusRequest| { &mut m.SectorId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetSealStatusRequest>(
                    "FilGetSealStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetSealStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilGetSealStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetSealStatusRequest,
        };
        unsafe {
            instance.get(FilGetSealStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilGetSealStatusRequest {
    fn clear(&mut self) {
        self.SectorId = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetSealStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetSealStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGeneratePoStRequest {
    // message fields
    pub CommRs: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub ChallengeSeed: ::std::vec::Vec<u8>,
    pub Faults: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGeneratePoStRequest {
    fn default() -> &'a FilGeneratePoStRequest {
        <FilGeneratePoStRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilGeneratePoStRequest {
    pub fn new() -> FilGeneratePoStRequest {
        ::std::default::Default::default()
    }

    // repeated bytes CommRs = 1;


    pub fn get_CommRs(&self) -> &[::std::vec::Vec<u8>] {
        &self.CommRs
    }
    pub fn clear_CommRs(&mut self) {
        self.CommRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommRs(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.CommRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CommRs(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.CommRs
    }

    // Take field
    pub fn take_CommRs(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.CommRs, ::protobuf::RepeatedField::new())
    }

    // bytes ChallengeSeed = 2;


    pub fn get_ChallengeSeed(&self) -> &[u8] {
        &self.ChallengeSeed
    }
    pub fn clear_ChallengeSeed(&mut self) {
        self.ChallengeSeed.clear();
    }

    // Param is passed by value, moved
    pub fn set_ChallengeSeed(&mut self, v: ::std::vec::Vec<u8>) {
        self.ChallengeSeed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ChallengeSeed(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ChallengeSeed
    }

    // Take field
    pub fn take_ChallengeSeed(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ChallengeSeed, ::std::vec::Vec::new())
    }

    // repeated uint64 Faults = 3;


    pub fn get_Faults(&self) -> &[u64] {
        &self.Faults
    }
    pub fn clear_Faults(&mut self) {
        self.Faults.clear();
    }

    // Param is passed by value, moved
    pub fn set_Faults(&mut self, v: ::std::vec::Vec<u64>) {
        self.Faults = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Faults(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.Faults
    }

    // Take field
    pub fn take_Faults(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.Faults, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilGeneratePoStRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.CommRs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ChallengeSeed)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.Faults)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.CommRs {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if !self.ChallengeSeed.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ChallengeSeed);
        }
        for value in &self.Faults {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.CommRs {
            os.write_bytes(1, &v)?;
        };
        if !self.ChallengeSeed.is_empty() {
            os.write_bytes(2, &self.ChallengeSeed)?;
        }
        for v in &self.Faults {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGeneratePoStRequest {
        FilGeneratePoStRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommRs",
                    |m: &FilGeneratePoStRequest| { &m.CommRs },
                    |m: &mut FilGeneratePoStRequest| { &mut m.CommRs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ChallengeSeed",
                    |m: &FilGeneratePoStRequest| { &m.ChallengeSeed },
                    |m: &mut FilGeneratePoStRequest| { &mut m.ChallengeSeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Faults",
                    |m: &FilGeneratePoStRequest| { &m.Faults },
                    |m: &mut FilGeneratePoStRequest| { &mut m.Faults },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGeneratePoStRequest>(
                    "FilGeneratePoStRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGeneratePoStRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilGeneratePoStRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGeneratePoStRequest,
        };
        unsafe {
            instance.get(FilGeneratePoStRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilGeneratePoStRequest {
    fn clear(&mut self) {
        self.CommRs.clear();
        self.ChallengeSeed.clear();
        self.Faults.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGeneratePoStRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGeneratePoStRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSectorClass {
    // message fields
    pub SectorSize: u64,
    pub PoRepProofPartitions: u64,
    pub PoStProofPartitions: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSectorClass {
    fn default() -> &'a FilSectorClass {
        <FilSectorClass as ::protobuf::Message>::default_instance()
    }
}

impl FilSectorClass {
    pub fn new() -> FilSectorClass {
        ::std::default::Default::default()
    }

    // uint64 SectorSize = 1;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }

    // uint64 PoRepProofPartitions = 2;


    pub fn get_PoRepProofPartitions(&self) -> u64 {
        self.PoRepProofPartitions
    }
    pub fn clear_PoRepProofPartitions(&mut self) {
        self.PoRepProofPartitions = 0;
    }

    // Param is passed by value, moved
    pub fn set_PoRepProofPartitions(&mut self, v: u64) {
        self.PoRepProofPartitions = v;
    }

    // uint64 PoStProofPartitions = 3;


    pub fn get_PoStProofPartitions(&self) -> u64 {
        self.PoStProofPartitions
    }
    pub fn clear_PoStProofPartitions(&mut self) {
        self.PoStProofPartitions = 0;
    }

    // Param is passed by value, moved
    pub fn set_PoStProofPartitions(&mut self, v: u64) {
        self.PoStProofPartitions = v;
    }
}

impl ::protobuf::Message for FilSectorClass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PoRepProofPartitions = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PoStProofPartitions = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.PoRepProofPartitions != 0 {
            my_size += ::protobuf::rt::value_size(2, self.PoRepProofPartitions, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.PoStProofPartitions != 0 {
            my_size += ::protobuf::rt::value_size(3, self.PoStProofPartitions, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorSize != 0 {
            os.write_uint64(1, self.SectorSize)?;
        }
        if self.PoRepProofPartitions != 0 {
            os.write_uint64(2, self.PoRepProofPartitions)?;
        }
        if self.PoStProofPartitions != 0 {
            os.write_uint64(3, self.PoStProofPartitions)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSectorClass {
        FilSectorClass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilSectorClass| { &m.SectorSize },
                    |m: &mut FilSectorClass| { &mut m.SectorSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PoRepProofPartitions",
                    |m: &FilSectorClass| { &m.PoRepProofPartitions },
                    |m: &mut FilSectorClass| { &mut m.PoRepProofPartitions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PoStProofPartitions",
                    |m: &FilSectorClass| { &m.PoStProofPartitions },
                    |m: &mut FilSectorClass| { &mut m.PoStProofPartitions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSectorClass>(
                    "FilSectorClass",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSectorClass {
        static mut instance: ::protobuf::lazy::Lazy<FilSectorClass> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSectorClass,
        };
        unsafe {
            instance.get(FilSectorClass::new)
        }
    }
}

impl ::protobuf::Clear for FilSectorClass {
    fn clear(&mut self) {
        self.SectorSize = 0;
        self.PoRepProofPartitions = 0;
        self.PoStProofPartitions = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSectorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSectorClass {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilInitSectorBuilderRequest {
    // message fields
    pub SectorClass: ::protobuf::SingularPtrField<FilSectorClass>,
    pub LastCommittedSectorId: u64,
    pub MetaDataDir: ::std::string::String,
    pub ProverId: ::std::vec::Vec<u8>,
    pub SealedSectorDir: ::std::string::String,
    pub StagedSectorDir: ::std::string::String,
    pub MaxNumStagedSectors: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilInitSectorBuilderRequest {
    fn default() -> &'a FilInitSectorBuilderRequest {
        <FilInitSectorBuilderRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilInitSectorBuilderRequest {
    pub fn new() -> FilInitSectorBuilderRequest {
        ::std::default::Default::default()
    }

    // .FilSectorClass SectorClass = 1;


    pub fn get_SectorClass(&self) -> &FilSectorClass {
        self.SectorClass.as_ref().unwrap_or_else(|| FilSectorClass::default_instance())
    }
    pub fn clear_SectorClass(&mut self) {
        self.SectorClass.clear();
    }

    pub fn has_SectorClass(&self) -> bool {
        self.SectorClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SectorClass(&mut self, v: FilSectorClass) {
        self.SectorClass = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SectorClass(&mut self) -> &mut FilSectorClass {
        if self.SectorClass.is_none() {
            self.SectorClass.set_default();
        }
        self.SectorClass.as_mut().unwrap()
    }

    // Take field
    pub fn take_SectorClass(&mut self) -> FilSectorClass {
        self.SectorClass.take().unwrap_or_else(|| FilSectorClass::new())
    }

    // uint64 LastCommittedSectorId = 2;


    pub fn get_LastCommittedSectorId(&self) -> u64 {
        self.LastCommittedSectorId
    }
    pub fn clear_LastCommittedSectorId(&mut self) {
        self.LastCommittedSectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_LastCommittedSectorId(&mut self, v: u64) {
        self.LastCommittedSectorId = v;
    }

    // string MetaDataDir = 3;


    pub fn get_MetaDataDir(&self) -> &str {
        &self.MetaDataDir
    }
    pub fn clear_MetaDataDir(&mut self) {
        self.MetaDataDir.clear();
    }

    // Param is passed by value, moved
    pub fn set_MetaDataDir(&mut self, v: ::std::string::String) {
        self.MetaDataDir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MetaDataDir(&mut self) -> &mut ::std::string::String {
        &mut self.MetaDataDir
    }

    // Take field
    pub fn take_MetaDataDir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.MetaDataDir, ::std::string::String::new())
    }

    // bytes ProverId = 4;


    pub fn get_ProverId(&self) -> &[u8] {
        &self.ProverId
    }
    pub fn clear_ProverId(&mut self) {
        self.ProverId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProverId(&mut self, v: ::std::vec::Vec<u8>) {
        self.ProverId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProverId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ProverId
    }

    // Take field
    pub fn take_ProverId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ProverId, ::std::vec::Vec::new())
    }

    // string SealedSectorDir = 5;


    pub fn get_SealedSectorDir(&self) -> &str {
        &self.SealedSectorDir
    }
    pub fn clear_SealedSectorDir(&mut self) {
        self.SealedSectorDir.clear();
    }

    // Param is passed by value, moved
    pub fn set_SealedSectorDir(&mut self, v: ::std::string::String) {
        self.SealedSectorDir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SealedSectorDir(&mut self) -> &mut ::std::string::String {
        &mut self.SealedSectorDir
    }

    // Take field
    pub fn take_SealedSectorDir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SealedSectorDir, ::std::string::String::new())
    }

    // string StagedSectorDir = 6;


    pub fn get_StagedSectorDir(&self) -> &str {
        &self.StagedSectorDir
    }
    pub fn clear_StagedSectorDir(&mut self) {
        self.StagedSectorDir.clear();
    }

    // Param is passed by value, moved
    pub fn set_StagedSectorDir(&mut self, v: ::std::string::String) {
        self.StagedSectorDir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_StagedSectorDir(&mut self) -> &mut ::std::string::String {
        &mut self.StagedSectorDir
    }

    // Take field
    pub fn take_StagedSectorDir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.StagedSectorDir, ::std::string::String::new())
    }

    // uint64 MaxNumStagedSectors = 7;


    pub fn get_MaxNumStagedSectors(&self) -> u64 {
        self.MaxNumStagedSectors
    }
    pub fn clear_MaxNumStagedSectors(&mut self) {
        self.MaxNumStagedSectors = 0;
    }

    // Param is passed by value, moved
    pub fn set_MaxNumStagedSectors(&mut self, v: u64) {
        self.MaxNumStagedSectors = v;
    }
}

impl ::protobuf::Message for FilInitSectorBuilderRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.SectorClass {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SectorClass)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.LastCommittedSectorId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.MetaDataDir)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ProverId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SealedSectorDir)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.StagedSectorDir)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.MaxNumStagedSectors = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.SectorClass.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.LastCommittedSectorId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.LastCommittedSectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.MetaDataDir.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.MetaDataDir);
        }
        if !self.ProverId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ProverId);
        }
        if !self.SealedSectorDir.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.SealedSectorDir);
        }
        if !self.StagedSectorDir.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.StagedSectorDir);
        }
        if self.MaxNumStagedSectors != 0 {
            my_size += ::protobuf::rt::value_size(7, self.MaxNumStagedSectors, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.SectorClass.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.LastCommittedSectorId != 0 {
            os.write_uint64(2, self.LastCommittedSectorId)?;
        }
        if !self.MetaDataDir.is_empty() {
            os.write_string(3, &self.MetaDataDir)?;
        }
        if !self.ProverId.is_empty() {
            os.write_bytes(4, &self.ProverId)?;
        }
        if !self.SealedSectorDir.is_empty() {
            os.write_string(5, &self.SealedSectorDir)?;
        }
        if !self.StagedSectorDir.is_empty() {
            os.write_string(6, &self.StagedSectorDir)?;
        }
        if self.MaxNumStagedSectors != 0 {
            os.write_uint64(7, self.MaxNumStagedSectors)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilInitSectorBuilderRequest {
        FilInitSectorBuilderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilSectorClass>>(
                    "SectorClass",
                    |m: &FilInitSectorBuilderRequest| { &m.SectorClass },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.SectorClass },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "LastCommittedSectorId",
                    |m: &FilInitSectorBuilderRequest| { &m.LastCommittedSectorId },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.LastCommittedSectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "MetaDataDir",
                    |m: &FilInitSectorBuilderRequest| { &m.MetaDataDir },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.MetaDataDir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ProverId",
                    |m: &FilInitSectorBuilderRequest| { &m.ProverId },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.ProverId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SealedSectorDir",
                    |m: &FilInitSectorBuilderRequest| { &m.SealedSectorDir },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.SealedSectorDir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "StagedSectorDir",
                    |m: &FilInitSectorBuilderRequest| { &m.StagedSectorDir },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.StagedSectorDir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "MaxNumStagedSectors",
                    |m: &FilInitSectorBuilderRequest| { &m.MaxNumStagedSectors },
                    |m: &mut FilInitSectorBuilderRequest| { &mut m.MaxNumStagedSectors },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilInitSectorBuilderRequest>(
                    "FilInitSectorBuilderRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilInitSectorBuilderRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilInitSectorBuilderRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilInitSectorBuilderRequest,
        };
        unsafe {
            instance.get(FilInitSectorBuilderRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilInitSectorBuilderRequest {
    fn clear(&mut self) {
        self.SectorClass.clear();
        self.LastCommittedSectorId = 0;
        self.MetaDataDir.clear();
        self.ProverId.clear();
        self.SealedSectorDir.clear();
        self.StagedSectorDir.clear();
        self.MaxNumStagedSectors = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilInitSectorBuilderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilInitSectorBuilderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetSealedSectorsRequest {
    // message fields
    pub PerformHealthchecks: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetSealedSectorsRequest {
    fn default() -> &'a FilGetSealedSectorsRequest {
        <FilGetSealedSectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilGetSealedSectorsRequest {
    pub fn new() -> FilGetSealedSectorsRequest {
        ::std::default::Default::default()
    }

    // bool PerformHealthchecks = 1;


    pub fn get_PerformHealthchecks(&self) -> bool {
        self.PerformHealthchecks
    }
    pub fn clear_PerformHealthchecks(&mut self) {
        self.PerformHealthchecks = false;
    }

    // Param is passed by value, moved
    pub fn set_PerformHealthchecks(&mut self, v: bool) {
        self.PerformHealthchecks = v;
    }
}

impl ::protobuf::Message for FilGetSealedSectorsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.PerformHealthchecks = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.PerformHealthchecks != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.PerformHealthchecks != false {
            os.write_bool(1, self.PerformHealthchecks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetSealedSectorsRequest {
        FilGetSealedSectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "PerformHealthchecks",
                    |m: &FilGetSealedSectorsRequest| { &m.PerformHealthchecks },
                    |m: &mut FilGetSealedSectorsRequest| { &mut m.PerformHealthchecks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetSealedSectorsRequest>(
                    "FilGetSealedSectorsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetSealedSectorsRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilGetSealedSectorsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetSealedSectorsRequest,
        };
        unsafe {
            instance.get(FilGetSealedSectorsRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilGetSealedSectorsRequest {
    fn clear(&mut self) {
        self.PerformHealthchecks = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetSealedSectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetSealedSectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilReadPieceFromSealedSectorRequest {
    // message fields
    pub PieceKey: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilReadPieceFromSealedSectorRequest {
    fn default() -> &'a FilReadPieceFromSealedSectorRequest {
        <FilReadPieceFromSealedSectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilReadPieceFromSealedSectorRequest {
    pub fn new() -> FilReadPieceFromSealedSectorRequest {
        ::std::default::Default::default()
    }

    // string PieceKey = 1;


    pub fn get_PieceKey(&self) -> &str {
        &self.PieceKey
    }
    pub fn clear_PieceKey(&mut self) {
        self.PieceKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceKey(&mut self, v: ::std::string::String) {
        self.PieceKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PieceKey(&mut self) -> &mut ::std::string::String {
        &mut self.PieceKey
    }

    // Take field
    pub fn take_PieceKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PieceKey, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilReadPieceFromSealedSectorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PieceKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PieceKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PieceKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PieceKey.is_empty() {
            os.write_string(1, &self.PieceKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilReadPieceFromSealedSectorRequest {
        FilReadPieceFromSealedSectorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PieceKey",
                    |m: &FilReadPieceFromSealedSectorRequest| { &m.PieceKey },
                    |m: &mut FilReadPieceFromSealedSectorRequest| { &mut m.PieceKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilReadPieceFromSealedSectorRequest>(
                    "FilReadPieceFromSealedSectorRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilReadPieceFromSealedSectorRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilReadPieceFromSealedSectorRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilReadPieceFromSealedSectorRequest,
        };
        unsafe {
            instance.get(FilReadPieceFromSealedSectorRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilReadPieceFromSealedSectorRequest {
    fn clear(&mut self) {
        self.PieceKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilReadPieceFromSealedSectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilReadPieceFromSealedSectorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSealRequest {
    // message fields
    pub Config: ::protobuf::SingularPtrField<FilPoRepConfig>,
    pub Data: ::std::vec::Vec<u8>,
    pub ProverId: ::std::vec::Vec<u8>,
    pub SectorId: u64,
    pub Pieces: ::protobuf::RepeatedField<super::response::FilPieceMetadata>,
    pub PieceLengths: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSealRequest {
    fn default() -> &'a FilSealRequest {
        <FilSealRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilSealRequest {
    pub fn new() -> FilSealRequest {
        ::std::default::Default::default()
    }

    // .FilPoRepConfig Config = 1;


    pub fn get_Config(&self) -> &FilPoRepConfig {
        self.Config.as_ref().unwrap_or_else(|| FilPoRepConfig::default_instance())
    }
    pub fn clear_Config(&mut self) {
        self.Config.clear();
    }

    pub fn has_Config(&self) -> bool {
        self.Config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Config(&mut self, v: FilPoRepConfig) {
        self.Config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Config(&mut self) -> &mut FilPoRepConfig {
        if self.Config.is_none() {
            self.Config.set_default();
        }
        self.Config.as_mut().unwrap()
    }

    // Take field
    pub fn take_Config(&mut self) -> FilPoRepConfig {
        self.Config.take().unwrap_or_else(|| FilPoRepConfig::new())
    }

    // bytes Data = 2;


    pub fn get_Data(&self) -> &[u8] {
        &self.Data
    }
    pub fn clear_Data(&mut self) {
        self.Data.clear();
    }

    // Param is passed by value, moved
    pub fn set_Data(&mut self, v: ::std::vec::Vec<u8>) {
        self.Data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Data
    }

    // Take field
    pub fn take_Data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Data, ::std::vec::Vec::new())
    }

    // bytes ProverId = 3;


    pub fn get_ProverId(&self) -> &[u8] {
        &self.ProverId
    }
    pub fn clear_ProverId(&mut self) {
        self.ProverId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProverId(&mut self, v: ::std::vec::Vec<u8>) {
        self.ProverId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProverId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ProverId
    }

    // Take field
    pub fn take_ProverId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ProverId, ::std::vec::Vec::new())
    }

    // uint64 SectorId = 4;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }

    // repeated .FilPieceMetadata Pieces = 6;


    pub fn get_Pieces(&self) -> &[super::response::FilPieceMetadata] {
        &self.Pieces
    }
    pub fn clear_Pieces(&mut self) {
        self.Pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_Pieces(&mut self, v: ::protobuf::RepeatedField<super::response::FilPieceMetadata>) {
        self.Pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Pieces(&mut self) -> &mut ::protobuf::RepeatedField<super::response::FilPieceMetadata> {
        &mut self.Pieces
    }

    // Take field
    pub fn take_Pieces(&mut self) -> ::protobuf::RepeatedField<super::response::FilPieceMetadata> {
        ::std::mem::replace(&mut self.Pieces, ::protobuf::RepeatedField::new())
    }

    // repeated uint64 PieceLengths = 5;


    pub fn get_PieceLengths(&self) -> &[u64] {
        &self.PieceLengths
    }
    pub fn clear_PieceLengths(&mut self) {
        self.PieceLengths.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceLengths(&mut self, v: ::std::vec::Vec<u64>) {
        self.PieceLengths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_PieceLengths(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.PieceLengths
    }

    // Take field
    pub fn take_PieceLengths(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.PieceLengths, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilSealRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.Config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ProverId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Pieces)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.PieceLengths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.Data);
        }
        if !self.ProverId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ProverId);
        }
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.PieceLengths {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Data.is_empty() {
            os.write_bytes(2, &self.Data)?;
        }
        if !self.ProverId.is_empty() {
            os.write_bytes(3, &self.ProverId)?;
        }
        if self.SectorId != 0 {
            os.write_uint64(4, self.SectorId)?;
        }
        for v in &self.Pieces {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.PieceLengths {
            os.write_uint64(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSealRequest {
        FilSealRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilPoRepConfig>>(
                    "Config",
                    |m: &FilSealRequest| { &m.Config },
                    |m: &mut FilSealRequest| { &mut m.Config },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Data",
                    |m: &FilSealRequest| { &m.Data },
                    |m: &mut FilSealRequest| { &mut m.Data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ProverId",
                    |m: &FilSealRequest| { &m.ProverId },
                    |m: &mut FilSealRequest| { &mut m.ProverId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilSealRequest| { &m.SectorId },
                    |m: &mut FilSealRequest| { &mut m.SectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::response::FilPieceMetadata>>(
                    "Pieces",
                    |m: &FilSealRequest| { &m.Pieces },
                    |m: &mut FilSealRequest| { &mut m.Pieces },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PieceLengths",
                    |m: &FilSealRequest| { &m.PieceLengths },
                    |m: &mut FilSealRequest| { &mut m.PieceLengths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSealRequest>(
                    "FilSealRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSealRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilSealRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSealRequest,
        };
        unsafe {
            instance.get(FilSealRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilSealRequest {
    fn clear(&mut self) {
        self.Config.clear();
        self.Data.clear();
        self.ProverId.clear();
        self.SectorId = 0;
        self.Pieces.clear();
        self.PieceLengths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSealRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetSoonSealRequest {
    // message fields
    pub SealAllStagedSectors: bool,
    pub ProverId: ::std::vec::Vec<u8>,
    pub SectorSize: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetSoonSealRequest {
    fn default() -> &'a FilGetSoonSealRequest {
        <FilGetSoonSealRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilGetSoonSealRequest {
    pub fn new() -> FilGetSoonSealRequest {
        ::std::default::Default::default()
    }

    // bool SealAllStagedSectors = 1;


    pub fn get_SealAllStagedSectors(&self) -> bool {
        self.SealAllStagedSectors
    }
    pub fn clear_SealAllStagedSectors(&mut self) {
        self.SealAllStagedSectors = false;
    }

    // Param is passed by value, moved
    pub fn set_SealAllStagedSectors(&mut self, v: bool) {
        self.SealAllStagedSectors = v;
    }

    // bytes ProverId = 2;


    pub fn get_ProverId(&self) -> &[u8] {
        &self.ProverId
    }
    pub fn clear_ProverId(&mut self) {
        self.ProverId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProverId(&mut self, v: ::std::vec::Vec<u8>) {
        self.ProverId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProverId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ProverId
    }

    // Take field
    pub fn take_ProverId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ProverId, ::std::vec::Vec::new())
    }

    // uint64 SectorSize = 3;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }
}

impl ::protobuf::Message for FilGetSoonSealRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.SealAllStagedSectors = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ProverId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SealAllStagedSectors != false {
            my_size += 2;
        }
        if !self.ProverId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ProverId);
        }
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SealAllStagedSectors != false {
            os.write_bool(1, self.SealAllStagedSectors)?;
        }
        if !self.ProverId.is_empty() {
            os.write_bytes(2, &self.ProverId)?;
        }
        if self.SectorSize != 0 {
            os.write_uint64(3, self.SectorSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetSoonSealRequest {
        FilGetSoonSealRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "SealAllStagedSectors",
                    |m: &FilGetSoonSealRequest| { &m.SealAllStagedSectors },
                    |m: &mut FilGetSoonSealRequest| { &mut m.SealAllStagedSectors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ProverId",
                    |m: &FilGetSoonSealRequest| { &m.ProverId },
                    |m: &mut FilGetSoonSealRequest| { &mut m.ProverId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilGetSoonSealRequest| { &m.SectorSize },
                    |m: &mut FilGetSoonSealRequest| { &mut m.SectorSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetSoonSealRequest>(
                    "FilGetSoonSealRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetSoonSealRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilGetSoonSealRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetSoonSealRequest,
        };
        unsafe {
            instance.get(FilGetSoonSealRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilGetSoonSealRequest {
    fn clear(&mut self) {
        self.SealAllStagedSectors = false;
        self.ProverId.clear();
        self.SectorSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetSoonSealRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetSoonSealRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGetSoonSealResponse {
    // message fields
    pub Seals: ::protobuf::RepeatedField<FilSealRequest>,
    pub Status: super::response::FilResponseStatus,
    pub ErrorMsg: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGetSoonSealResponse {
    fn default() -> &'a FilGetSoonSealResponse {
        <FilGetSoonSealResponse as ::protobuf::Message>::default_instance()
    }
}

impl FilGetSoonSealResponse {
    pub fn new() -> FilGetSoonSealResponse {
        ::std::default::Default::default()
    }

    // repeated .FilSealRequest Seals = 1;


    pub fn get_Seals(&self) -> &[FilSealRequest] {
        &self.Seals
    }
    pub fn clear_Seals(&mut self) {
        self.Seals.clear();
    }

    // Param is passed by value, moved
    pub fn set_Seals(&mut self, v: ::protobuf::RepeatedField<FilSealRequest>) {
        self.Seals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Seals(&mut self) -> &mut ::protobuf::RepeatedField<FilSealRequest> {
        &mut self.Seals
    }

    // Take field
    pub fn take_Seals(&mut self) -> ::protobuf::RepeatedField<FilSealRequest> {
        ::std::mem::replace(&mut self.Seals, ::protobuf::RepeatedField::new())
    }

    // .FilResponseStatus Status = 2;


    pub fn get_Status(&self) -> super::response::FilResponseStatus {
        self.Status
    }
    pub fn clear_Status(&mut self) {
        self.Status = super::response::FilResponseStatus::NoError;
    }

    // Param is passed by value, moved
    pub fn set_Status(&mut self, v: super::response::FilResponseStatus) {
        self.Status = v;
    }

    // string ErrorMsg = 3;


    pub fn get_ErrorMsg(&self) -> &str {
        &self.ErrorMsg
    }
    pub fn clear_ErrorMsg(&mut self) {
        self.ErrorMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ErrorMsg(&mut self, v: ::std::string::String) {
        self.ErrorMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ErrorMsg(&mut self) -> &mut ::std::string::String {
        &mut self.ErrorMsg
    }

    // Take field
    pub fn take_ErrorMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ErrorMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilGetSoonSealResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.Seals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Seals)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ErrorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Seals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.Status != super::response::FilResponseStatus::NoError {
            my_size += ::protobuf::rt::enum_size(2, self.Status);
        }
        if !self.ErrorMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ErrorMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Seals {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.Status != super::response::FilResponseStatus::NoError {
            os.write_enum(2, self.Status.value())?;
        }
        if !self.ErrorMsg.is_empty() {
            os.write_string(3, &self.ErrorMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGetSoonSealResponse {
        FilGetSoonSealResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilSealRequest>>(
                    "Seals",
                    |m: &FilGetSoonSealResponse| { &m.Seals },
                    |m: &mut FilGetSoonSealResponse| { &mut m.Seals },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::response::FilResponseStatus>>(
                    "Status",
                    |m: &FilGetSoonSealResponse| { &m.Status },
                    |m: &mut FilGetSoonSealResponse| { &mut m.Status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ErrorMsg",
                    |m: &FilGetSoonSealResponse| { &m.ErrorMsg },
                    |m: &mut FilGetSoonSealResponse| { &mut m.ErrorMsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGetSoonSealResponse>(
                    "FilGetSoonSealResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGetSoonSealResponse {
        static mut instance: ::protobuf::lazy::Lazy<FilGetSoonSealResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGetSoonSealResponse,
        };
        unsafe {
            instance.get(FilGetSoonSealResponse::new)
        }
    }
}

impl ::protobuf::Clear for FilGetSoonSealResponse {
    fn clear(&mut self) {
        self.Seals.clear();
        self.Status = super::response::FilResponseStatus::NoError;
        self.ErrorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGetSoonSealResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGetSoonSealResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilSealCallBackRequest {
    // message fields
    pub SealResult: ::protobuf::SingularPtrField<super::response::FilSealResponse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilSealCallBackRequest {
    fn default() -> &'a FilSealCallBackRequest {
        <FilSealCallBackRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilSealCallBackRequest {
    pub fn new() -> FilSealCallBackRequest {
        ::std::default::Default::default()
    }

    // .FilSealResponse SealResult = 1;


    pub fn get_SealResult(&self) -> &super::response::FilSealResponse {
        self.SealResult.as_ref().unwrap_or_else(|| super::response::FilSealResponse::default_instance())
    }
    pub fn clear_SealResult(&mut self) {
        self.SealResult.clear();
    }

    pub fn has_SealResult(&self) -> bool {
        self.SealResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SealResult(&mut self, v: super::response::FilSealResponse) {
        self.SealResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SealResult(&mut self) -> &mut super::response::FilSealResponse {
        if self.SealResult.is_none() {
            self.SealResult.set_default();
        }
        self.SealResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_SealResult(&mut self) -> super::response::FilSealResponse {
        self.SealResult.take().unwrap_or_else(|| super::response::FilSealResponse::new())
    }
}

impl ::protobuf::Message for FilSealCallBackRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.SealResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SealResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.SealResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.SealResult.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilSealCallBackRequest {
        FilSealCallBackRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::response::FilSealResponse>>(
                    "SealResult",
                    |m: &FilSealCallBackRequest| { &m.SealResult },
                    |m: &mut FilSealCallBackRequest| { &mut m.SealResult },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilSealCallBackRequest>(
                    "FilSealCallBackRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilSealCallBackRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilSealCallBackRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilSealCallBackRequest,
        };
        unsafe {
            instance.get(FilSealCallBackRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilSealCallBackRequest {
    fn clear(&mut self) {
        self.SealResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilSealCallBackRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilSealCallBackRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilPoRepConfig {
    // message fields
    pub SectorSize: u64,
    pub PoRepProofPartitions: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilPoRepConfig {
    fn default() -> &'a FilPoRepConfig {
        <FilPoRepConfig as ::protobuf::Message>::default_instance()
    }
}

impl FilPoRepConfig {
    pub fn new() -> FilPoRepConfig {
        ::std::default::Default::default()
    }

    // uint64 SectorSize = 1;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }

    // uint64 PoRepProofPartitions = 2;


    pub fn get_PoRepProofPartitions(&self) -> u64 {
        self.PoRepProofPartitions
    }
    pub fn clear_PoRepProofPartitions(&mut self) {
        self.PoRepProofPartitions = 0;
    }

    // Param is passed by value, moved
    pub fn set_PoRepProofPartitions(&mut self, v: u64) {
        self.PoRepProofPartitions = v;
    }
}

impl ::protobuf::Message for FilPoRepConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PoRepProofPartitions = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.PoRepProofPartitions != 0 {
            my_size += ::protobuf::rt::value_size(2, self.PoRepProofPartitions, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorSize != 0 {
            os.write_uint64(1, self.SectorSize)?;
        }
        if self.PoRepProofPartitions != 0 {
            os.write_uint64(2, self.PoRepProofPartitions)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilPoRepConfig {
        FilPoRepConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilPoRepConfig| { &m.SectorSize },
                    |m: &mut FilPoRepConfig| { &mut m.SectorSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PoRepProofPartitions",
                    |m: &FilPoRepConfig| { &m.PoRepProofPartitions },
                    |m: &mut FilPoRepConfig| { &mut m.PoRepProofPartitions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilPoRepConfig>(
                    "FilPoRepConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilPoRepConfig {
        static mut instance: ::protobuf::lazy::Lazy<FilPoRepConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilPoRepConfig,
        };
        unsafe {
            instance.get(FilPoRepConfig::new)
        }
    }
}

impl ::protobuf::Clear for FilPoRepConfig {
    fn clear(&mut self) {
        self.SectorSize = 0;
        self.PoRepProofPartitions = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilPoRepConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilPoRepConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilVerifySealRequest {
    // message fields
    pub Config: ::protobuf::SingularPtrField<FilPoRepConfig>,
    pub CommR: ::std::vec::Vec<u8>,
    pub CommD: ::std::vec::Vec<u8>,
    pub CommRs: ::std::vec::Vec<u8>,
    pub ProverId: ::std::vec::Vec<u8>,
    pub SectorId: u64,
    pub Proof: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilVerifySealRequest {
    fn default() -> &'a FilVerifySealRequest {
        <FilVerifySealRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilVerifySealRequest {
    pub fn new() -> FilVerifySealRequest {
        ::std::default::Default::default()
    }

    // .FilPoRepConfig Config = 1;


    pub fn get_Config(&self) -> &FilPoRepConfig {
        self.Config.as_ref().unwrap_or_else(|| FilPoRepConfig::default_instance())
    }
    pub fn clear_Config(&mut self) {
        self.Config.clear();
    }

    pub fn has_Config(&self) -> bool {
        self.Config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Config(&mut self, v: FilPoRepConfig) {
        self.Config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Config(&mut self) -> &mut FilPoRepConfig {
        if self.Config.is_none() {
            self.Config.set_default();
        }
        self.Config.as_mut().unwrap()
    }

    // Take field
    pub fn take_Config(&mut self) -> FilPoRepConfig {
        self.Config.take().unwrap_or_else(|| FilPoRepConfig::new())
    }

    // bytes CommR = 2;


    pub fn get_CommR(&self) -> &[u8] {
        &self.CommR
    }
    pub fn clear_CommR(&mut self) {
        self.CommR.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommR(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommR = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommR(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommR
    }

    // Take field
    pub fn take_CommR(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommR, ::std::vec::Vec::new())
    }

    // bytes CommD = 3;


    pub fn get_CommD(&self) -> &[u8] {
        &self.CommD
    }
    pub fn clear_CommD(&mut self) {
        self.CommD.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommD(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommD = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommD(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommD
    }

    // Take field
    pub fn take_CommD(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommD, ::std::vec::Vec::new())
    }

    // bytes CommRs = 4;


    pub fn get_CommRs(&self) -> &[u8] {
        &self.CommRs
    }
    pub fn clear_CommRs(&mut self) {
        self.CommRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommRs(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommRs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommRs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommRs
    }

    // Take field
    pub fn take_CommRs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommRs, ::std::vec::Vec::new())
    }

    // bytes ProverId = 5;


    pub fn get_ProverId(&self) -> &[u8] {
        &self.ProverId
    }
    pub fn clear_ProverId(&mut self) {
        self.ProverId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProverId(&mut self, v: ::std::vec::Vec<u8>) {
        self.ProverId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ProverId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ProverId
    }

    // Take field
    pub fn take_ProverId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ProverId, ::std::vec::Vec::new())
    }

    // uint64 SectorId = 6;


    pub fn get_SectorId(&self) -> u64 {
        self.SectorId
    }
    pub fn clear_SectorId(&mut self) {
        self.SectorId = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorId(&mut self, v: u64) {
        self.SectorId = v;
    }

    // bytes Proof = 7;


    pub fn get_Proof(&self) -> &[u8] {
        &self.Proof
    }
    pub fn clear_Proof(&mut self) {
        self.Proof.clear();
    }

    // Param is passed by value, moved
    pub fn set_Proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.Proof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Proof
    }

    // Take field
    pub fn take_Proof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Proof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilVerifySealRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.Config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommR)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommD)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommRs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ProverId)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorId = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.CommR.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.CommR);
        }
        if !self.CommD.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.CommD);
        }
        if !self.CommRs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.CommRs);
        }
        if !self.ProverId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.ProverId);
        }
        if self.SectorId != 0 {
            my_size += ::protobuf::rt::value_size(6, self.SectorId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.Proof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.CommR.is_empty() {
            os.write_bytes(2, &self.CommR)?;
        }
        if !self.CommD.is_empty() {
            os.write_bytes(3, &self.CommD)?;
        }
        if !self.CommRs.is_empty() {
            os.write_bytes(4, &self.CommRs)?;
        }
        if !self.ProverId.is_empty() {
            os.write_bytes(5, &self.ProverId)?;
        }
        if self.SectorId != 0 {
            os.write_uint64(6, self.SectorId)?;
        }
        if !self.Proof.is_empty() {
            os.write_bytes(7, &self.Proof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilVerifySealRequest {
        FilVerifySealRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilPoRepConfig>>(
                    "Config",
                    |m: &FilVerifySealRequest| { &m.Config },
                    |m: &mut FilVerifySealRequest| { &mut m.Config },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommR",
                    |m: &FilVerifySealRequest| { &m.CommR },
                    |m: &mut FilVerifySealRequest| { &mut m.CommR },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommD",
                    |m: &FilVerifySealRequest| { &m.CommD },
                    |m: &mut FilVerifySealRequest| { &mut m.CommD },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommRs",
                    |m: &FilVerifySealRequest| { &m.CommRs },
                    |m: &mut FilVerifySealRequest| { &mut m.CommRs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ProverId",
                    |m: &FilVerifySealRequest| { &m.ProverId },
                    |m: &mut FilVerifySealRequest| { &mut m.ProverId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorId",
                    |m: &FilVerifySealRequest| { &m.SectorId },
                    |m: &mut FilVerifySealRequest| { &mut m.SectorId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Proof",
                    |m: &FilVerifySealRequest| { &m.Proof },
                    |m: &mut FilVerifySealRequest| { &mut m.Proof },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilVerifySealRequest>(
                    "FilVerifySealRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilVerifySealRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilVerifySealRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilVerifySealRequest,
        };
        unsafe {
            instance.get(FilVerifySealRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilVerifySealRequest {
    fn clear(&mut self) {
        self.Config.clear();
        self.CommR.clear();
        self.CommD.clear();
        self.CommRs.clear();
        self.ProverId.clear();
        self.SectorId = 0;
        self.Proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilVerifySealRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilVerifySealRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilVerifyPieceRequest {
    // message fields
    pub PieceInclusionProof: ::std::vec::Vec<u8>,
    pub CommD: ::std::vec::Vec<u8>,
    pub CommP: ::std::vec::Vec<u8>,
    pub PieceSize: u64,
    pub SectorSize: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilVerifyPieceRequest {
    fn default() -> &'a FilVerifyPieceRequest {
        <FilVerifyPieceRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilVerifyPieceRequest {
    pub fn new() -> FilVerifyPieceRequest {
        ::std::default::Default::default()
    }

    // bytes PieceInclusionProof = 1;


    pub fn get_PieceInclusionProof(&self) -> &[u8] {
        &self.PieceInclusionProof
    }
    pub fn clear_PieceInclusionProof(&mut self) {
        self.PieceInclusionProof.clear();
    }

    // Param is passed by value, moved
    pub fn set_PieceInclusionProof(&mut self, v: ::std::vec::Vec<u8>) {
        self.PieceInclusionProof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PieceInclusionProof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.PieceInclusionProof
    }

    // Take field
    pub fn take_PieceInclusionProof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.PieceInclusionProof, ::std::vec::Vec::new())
    }

    // bytes CommD = 2;


    pub fn get_CommD(&self) -> &[u8] {
        &self.CommD
    }
    pub fn clear_CommD(&mut self) {
        self.CommD.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommD(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommD = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommD(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommD
    }

    // Take field
    pub fn take_CommD(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommD, ::std::vec::Vec::new())
    }

    // bytes CommP = 3;


    pub fn get_CommP(&self) -> &[u8] {
        &self.CommP
    }
    pub fn clear_CommP(&mut self) {
        self.CommP.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommP(&mut self, v: ::std::vec::Vec<u8>) {
        self.CommP = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CommP(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.CommP
    }

    // Take field
    pub fn take_CommP(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.CommP, ::std::vec::Vec::new())
    }

    // uint64 PieceSize = 4;


    pub fn get_PieceSize(&self) -> u64 {
        self.PieceSize
    }
    pub fn clear_PieceSize(&mut self) {
        self.PieceSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_PieceSize(&mut self, v: u64) {
        self.PieceSize = v;
    }

    // uint64 SectorSize = 5;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }
}

impl ::protobuf::Message for FilVerifyPieceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.PieceInclusionProof)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommD)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.CommP)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PieceSize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PieceInclusionProof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.PieceInclusionProof);
        }
        if !self.CommD.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.CommD);
        }
        if !self.CommP.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.CommP);
        }
        if self.PieceSize != 0 {
            my_size += ::protobuf::rt::value_size(4, self.PieceSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(5, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PieceInclusionProof.is_empty() {
            os.write_bytes(1, &self.PieceInclusionProof)?;
        }
        if !self.CommD.is_empty() {
            os.write_bytes(2, &self.CommD)?;
        }
        if !self.CommP.is_empty() {
            os.write_bytes(3, &self.CommP)?;
        }
        if self.PieceSize != 0 {
            os.write_uint64(4, self.PieceSize)?;
        }
        if self.SectorSize != 0 {
            os.write_uint64(5, self.SectorSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilVerifyPieceRequest {
        FilVerifyPieceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "PieceInclusionProof",
                    |m: &FilVerifyPieceRequest| { &m.PieceInclusionProof },
                    |m: &mut FilVerifyPieceRequest| { &mut m.PieceInclusionProof },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommD",
                    |m: &FilVerifyPieceRequest| { &m.CommD },
                    |m: &mut FilVerifyPieceRequest| { &mut m.CommD },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommP",
                    |m: &FilVerifyPieceRequest| { &m.CommP },
                    |m: &mut FilVerifyPieceRequest| { &mut m.CommP },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PieceSize",
                    |m: &FilVerifyPieceRequest| { &m.PieceSize },
                    |m: &mut FilVerifyPieceRequest| { &mut m.PieceSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilVerifyPieceRequest| { &m.SectorSize },
                    |m: &mut FilVerifyPieceRequest| { &mut m.SectorSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilVerifyPieceRequest>(
                    "FilVerifyPieceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilVerifyPieceRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilVerifyPieceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilVerifyPieceRequest,
        };
        unsafe {
            instance.get(FilVerifyPieceRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilVerifyPieceRequest {
    fn clear(&mut self) {
        self.PieceInclusionProof.clear();
        self.CommD.clear();
        self.CommP.clear();
        self.PieceSize = 0;
        self.SectorSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilVerifyPieceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilVerifyPieceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilPoStConfig {
    // message fields
    pub SectorSize: u64,
    pub PoStProofPartitions: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilPoStConfig {
    fn default() -> &'a FilPoStConfig {
        <FilPoStConfig as ::protobuf::Message>::default_instance()
    }
}

impl FilPoStConfig {
    pub fn new() -> FilPoStConfig {
        ::std::default::Default::default()
    }

    // uint64 SectorSize = 1;


    pub fn get_SectorSize(&self) -> u64 {
        self.SectorSize
    }
    pub fn clear_SectorSize(&mut self) {
        self.SectorSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_SectorSize(&mut self, v: u64) {
        self.SectorSize = v;
    }

    // uint64 PoStProofPartitions = 2;


    pub fn get_PoStProofPartitions(&self) -> u64 {
        self.PoStProofPartitions
    }
    pub fn clear_PoStProofPartitions(&mut self) {
        self.PoStProofPartitions = 0;
    }

    // Param is passed by value, moved
    pub fn set_PoStProofPartitions(&mut self, v: u64) {
        self.PoStProofPartitions = v;
    }
}

impl ::protobuf::Message for FilPoStConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.SectorSize = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.PoStProofPartitions = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.SectorSize != 0 {
            my_size += ::protobuf::rt::value_size(1, self.SectorSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.PoStProofPartitions != 0 {
            my_size += ::protobuf::rt::value_size(2, self.PoStProofPartitions, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.SectorSize != 0 {
            os.write_uint64(1, self.SectorSize)?;
        }
        if self.PoStProofPartitions != 0 {
            os.write_uint64(2, self.PoStProofPartitions)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilPoStConfig {
        FilPoStConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "SectorSize",
                    |m: &FilPoStConfig| { &m.SectorSize },
                    |m: &mut FilPoStConfig| { &mut m.SectorSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "PoStProofPartitions",
                    |m: &FilPoStConfig| { &m.PoStProofPartitions },
                    |m: &mut FilPoStConfig| { &mut m.PoStProofPartitions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilPoStConfig>(
                    "FilPoStConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilPoStConfig {
        static mut instance: ::protobuf::lazy::Lazy<FilPoStConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilPoStConfig,
        };
        unsafe {
            instance.get(FilPoStConfig::new)
        }
    }
}

impl ::protobuf::Clear for FilPoStConfig {
    fn clear(&mut self) {
        self.SectorSize = 0;
        self.PoStProofPartitions = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilPoStConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilPoStConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilVerifyPoStRequest {
    // message fields
    pub Config: ::protobuf::SingularPtrField<FilPoStConfig>,
    pub sector_ids: ::std::vec::Vec<u64>,
    pub faulty_sector_ids: ::std::vec::Vec<u64>,
    pub CommRs: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub ChallengeSeed: ::std::vec::Vec<u8>,
    pub Proofs: ::std::vec::Vec<u8>,
    pub Faults: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilVerifyPoStRequest {
    fn default() -> &'a FilVerifyPoStRequest {
        <FilVerifyPoStRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilVerifyPoStRequest {
    pub fn new() -> FilVerifyPoStRequest {
        ::std::default::Default::default()
    }

    // .FilPoStConfig Config = 1;


    pub fn get_Config(&self) -> &FilPoStConfig {
        self.Config.as_ref().unwrap_or_else(|| FilPoStConfig::default_instance())
    }
    pub fn clear_Config(&mut self) {
        self.Config.clear();
    }

    pub fn has_Config(&self) -> bool {
        self.Config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Config(&mut self, v: FilPoStConfig) {
        self.Config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Config(&mut self) -> &mut FilPoStConfig {
        if self.Config.is_none() {
            self.Config.set_default();
        }
        self.Config.as_mut().unwrap()
    }

    // Take field
    pub fn take_Config(&mut self) -> FilPoStConfig {
        self.Config.take().unwrap_or_else(|| FilPoStConfig::new())
    }

    // repeated uint64 sector_ids = 2;


    pub fn get_sector_ids(&self) -> &[u64] {
        &self.sector_ids
    }
    pub fn clear_sector_ids(&mut self) {
        self.sector_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_sector_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.sector_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sector_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.sector_ids
    }

    // Take field
    pub fn take_sector_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.sector_ids, ::std::vec::Vec::new())
    }

    // repeated uint64 faulty_sector_ids = 3;


    pub fn get_faulty_sector_ids(&self) -> &[u64] {
        &self.faulty_sector_ids
    }
    pub fn clear_faulty_sector_ids(&mut self) {
        self.faulty_sector_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_faulty_sector_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.faulty_sector_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_faulty_sector_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.faulty_sector_ids
    }

    // Take field
    pub fn take_faulty_sector_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.faulty_sector_ids, ::std::vec::Vec::new())
    }

    // repeated bytes CommRs = 4;


    pub fn get_CommRs(&self) -> &[::std::vec::Vec<u8>] {
        &self.CommRs
    }
    pub fn clear_CommRs(&mut self) {
        self.CommRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_CommRs(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.CommRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CommRs(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.CommRs
    }

    // Take field
    pub fn take_CommRs(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.CommRs, ::protobuf::RepeatedField::new())
    }

    // bytes ChallengeSeed = 5;


    pub fn get_ChallengeSeed(&self) -> &[u8] {
        &self.ChallengeSeed
    }
    pub fn clear_ChallengeSeed(&mut self) {
        self.ChallengeSeed.clear();
    }

    // Param is passed by value, moved
    pub fn set_ChallengeSeed(&mut self, v: ::std::vec::Vec<u8>) {
        self.ChallengeSeed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ChallengeSeed(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ChallengeSeed
    }

    // Take field
    pub fn take_ChallengeSeed(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ChallengeSeed, ::std::vec::Vec::new())
    }

    // bytes Proofs = 6;


    pub fn get_Proofs(&self) -> &[u8] {
        &self.Proofs
    }
    pub fn clear_Proofs(&mut self) {
        self.Proofs.clear();
    }

    // Param is passed by value, moved
    pub fn set_Proofs(&mut self, v: ::std::vec::Vec<u8>) {
        self.Proofs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Proofs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Proofs
    }

    // Take field
    pub fn take_Proofs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Proofs, ::std::vec::Vec::new())
    }

    // repeated uint64 Faults = 7;


    pub fn get_Faults(&self) -> &[u64] {
        &self.Faults
    }
    pub fn clear_Faults(&mut self) {
        self.Faults.clear();
    }

    // Param is passed by value, moved
    pub fn set_Faults(&mut self, v: ::std::vec::Vec<u64>) {
        self.Faults = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Faults(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.Faults
    }

    // Take field
    pub fn take_Faults(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.Faults, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FilVerifyPoStRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.Config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Config)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.sector_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.faulty_sector_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.CommRs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ChallengeSeed)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Proofs)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.Faults)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.sector_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.faulty_sector_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.CommRs {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if !self.ChallengeSeed.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.ChallengeSeed);
        }
        if !self.Proofs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.Proofs);
        }
        for value in &self.Faults {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.sector_ids {
            os.write_uint64(2, *v)?;
        };
        for v in &self.faulty_sector_ids {
            os.write_uint64(3, *v)?;
        };
        for v in &self.CommRs {
            os.write_bytes(4, &v)?;
        };
        if !self.ChallengeSeed.is_empty() {
            os.write_bytes(5, &self.ChallengeSeed)?;
        }
        if !self.Proofs.is_empty() {
            os.write_bytes(6, &self.Proofs)?;
        }
        for v in &self.Faults {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilVerifyPoStRequest {
        FilVerifyPoStRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilPoStConfig>>(
                    "Config",
                    |m: &FilVerifyPoStRequest| { &m.Config },
                    |m: &mut FilVerifyPoStRequest| { &mut m.Config },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sector_ids",
                    |m: &FilVerifyPoStRequest| { &m.sector_ids },
                    |m: &mut FilVerifyPoStRequest| { &mut m.sector_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "faulty_sector_ids",
                    |m: &FilVerifyPoStRequest| { &m.faulty_sector_ids },
                    |m: &mut FilVerifyPoStRequest| { &mut m.faulty_sector_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "CommRs",
                    |m: &FilVerifyPoStRequest| { &m.CommRs },
                    |m: &mut FilVerifyPoStRequest| { &mut m.CommRs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ChallengeSeed",
                    |m: &FilVerifyPoStRequest| { &m.ChallengeSeed },
                    |m: &mut FilVerifyPoStRequest| { &mut m.ChallengeSeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Proofs",
                    |m: &FilVerifyPoStRequest| { &m.Proofs },
                    |m: &mut FilVerifyPoStRequest| { &mut m.Proofs },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Faults",
                    |m: &FilVerifyPoStRequest| { &m.Faults },
                    |m: &mut FilVerifyPoStRequest| { &mut m.Faults },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilVerifyPoStRequest>(
                    "FilVerifyPoStRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilVerifyPoStRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilVerifyPoStRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilVerifyPoStRequest,
        };
        unsafe {
            instance.get(FilVerifyPoStRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilVerifyPoStRequest {
    fn clear(&mut self) {
        self.Config.clear();
        self.sector_ids.clear();
        self.faulty_sector_ids.clear();
        self.CommRs.clear();
        self.ChallengeSeed.clear();
        self.Proofs.clear();
        self.Faults.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilVerifyPoStRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilVerifyPoStRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FilGeneratePieceCommitentRequest {
    // message fields
    pub UnpaddedPieceData: ::std::vec::Vec<u8>,
    pub UnpaddedPieceSize: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilGeneratePieceCommitentRequest {
    fn default() -> &'a FilGeneratePieceCommitentRequest {
        <FilGeneratePieceCommitentRequest as ::protobuf::Message>::default_instance()
    }
}

impl FilGeneratePieceCommitentRequest {
    pub fn new() -> FilGeneratePieceCommitentRequest {
        ::std::default::Default::default()
    }

    // bytes UnpaddedPieceData = 1;


    pub fn get_UnpaddedPieceData(&self) -> &[u8] {
        &self.UnpaddedPieceData
    }
    pub fn clear_UnpaddedPieceData(&mut self) {
        self.UnpaddedPieceData.clear();
    }

    // Param is passed by value, moved
    pub fn set_UnpaddedPieceData(&mut self, v: ::std::vec::Vec<u8>) {
        self.UnpaddedPieceData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_UnpaddedPieceData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.UnpaddedPieceData
    }

    // Take field
    pub fn take_UnpaddedPieceData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.UnpaddedPieceData, ::std::vec::Vec::new())
    }

    // uint64 UnpaddedPieceSize = 2;


    pub fn get_UnpaddedPieceSize(&self) -> u64 {
        self.UnpaddedPieceSize
    }
    pub fn clear_UnpaddedPieceSize(&mut self) {
        self.UnpaddedPieceSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_UnpaddedPieceSize(&mut self, v: u64) {
        self.UnpaddedPieceSize = v;
    }
}

impl ::protobuf::Message for FilGeneratePieceCommitentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.UnpaddedPieceData)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.UnpaddedPieceSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.UnpaddedPieceData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.UnpaddedPieceData);
        }
        if self.UnpaddedPieceSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.UnpaddedPieceSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.UnpaddedPieceData.is_empty() {
            os.write_bytes(1, &self.UnpaddedPieceData)?;
        }
        if self.UnpaddedPieceSize != 0 {
            os.write_uint64(2, self.UnpaddedPieceSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilGeneratePieceCommitentRequest {
        FilGeneratePieceCommitentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "UnpaddedPieceData",
                    |m: &FilGeneratePieceCommitentRequest| { &m.UnpaddedPieceData },
                    |m: &mut FilGeneratePieceCommitentRequest| { &mut m.UnpaddedPieceData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "UnpaddedPieceSize",
                    |m: &FilGeneratePieceCommitentRequest| { &m.UnpaddedPieceSize },
                    |m: &mut FilGeneratePieceCommitentRequest| { &mut m.UnpaddedPieceSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilGeneratePieceCommitentRequest>(
                    "FilGeneratePieceCommitentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilGeneratePieceCommitentRequest {
        static mut instance: ::protobuf::lazy::Lazy<FilGeneratePieceCommitentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilGeneratePieceCommitentRequest,
        };
        unsafe {
            instance.get(FilGeneratePieceCommitentRequest::new)
        }
    }
}

impl ::protobuf::Clear for FilGeneratePieceCommitentRequest {
    fn clear(&mut self) {
        self.UnpaddedPieceData.clear();
        self.UnpaddedPieceSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilGeneratePieceCommitentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilGeneratePieceCommitentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rrequest.proto\x1a\x0frustproto.proto\x1a\x0eresponse.proto\"\xa8\x01\
    \n\x12FilAddPieceRequest\x12\x1a\n\x08PieceKey\x18\x01\x20\x01(\tR\x08Pi\
    eceKey\x12*\n\x10PieceBytesAmount\x18\x02\x20\x01(\x04R\x10PieceBytesAmo\
    unt\x12\x1c\n\tPiecePath\x18\x03\x20\x01(\tR\tPiecePath\x12,\n\x11Second\
    sSinceEpoch\x18\x04\x20\x01(\x04R\x11SecondsSinceEpoch\"v\n\x18FilAddPie\
    ceExtendRequest\x12\x1a\n\x08PieceKey\x18\x01\x20\x01(\tR\x08PieceKey\
    \x12*\n\x10PieceBytesAmount\x18\x02\x20\x01(\x04R\x10PieceBytesAmount\
    \x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"J\n(FilGetMaxUserBytes\
    PerStagedSectorRequest\x12\x1e\n\nSectorSize\x18\x01\x20\x01(\x04R\nSect\
    orSize\"5\n\x17FilGetSealStatusRequest\x12\x1a\n\x08SectorId\x18\x01\x20\
    \x01(\x04R\x08SectorId\"n\n\x16FilGeneratePoStRequest\x12\x16\n\x06CommR\
    s\x18\x01\x20\x03(\x0cR\x06CommRs\x12$\n\rChallengeSeed\x18\x02\x20\x01(\
    \x0cR\rChallengeSeed\x12\x16\n\x06Faults\x18\x03\x20\x03(\x04R\x06Faults\
    \"\x96\x01\n\x0eFilSectorClass\x12\x1e\n\nSectorSize\x18\x01\x20\x01(\
    \x04R\nSectorSize\x122\n\x14PoRepProofPartitions\x18\x02\x20\x01(\x04R\
    \x14PoRepProofPartitions\x120\n\x13PoStProofPartitions\x18\x03\x20\x01(\
    \x04R\x13PoStProofPartitions\"\xca\x02\n\x1bFilInitSectorBuilderRequest\
    \x121\n\x0bSectorClass\x18\x01\x20\x01(\x0b2\x0f.FilSectorClassR\x0bSect\
    orClass\x124\n\x15LastCommittedSectorId\x18\x02\x20\x01(\x04R\x15LastCom\
    mittedSectorId\x12\x20\n\x0bMetaDataDir\x18\x03\x20\x01(\tR\x0bMetaDataD\
    ir\x12\x1a\n\x08ProverId\x18\x04\x20\x01(\x0cR\x08ProverId\x12(\n\x0fSea\
    ledSectorDir\x18\x05\x20\x01(\tR\x0fSealedSectorDir\x12(\n\x0fStagedSect\
    orDir\x18\x06\x20\x01(\tR\x0fStagedSectorDir\x120\n\x13MaxNumStagedSecto\
    rs\x18\x07\x20\x01(\x04R\x13MaxNumStagedSectors\"N\n\x1aFilGetSealedSect\
    orsRequest\x120\n\x13PerformHealthchecks\x18\x01\x20\x01(\x08R\x13Perfor\
    mHealthchecks\"A\n#FilReadPieceFromSealedSectorRequest\x12\x1a\n\x08Piec\
    eKey\x18\x01\x20\x01(\tR\x08PieceKey\"\xd4\x01\n\x0eFilSealRequest\x12'\
    \n\x06Config\x18\x01\x20\x01(\x0b2\x0f.FilPoRepConfigR\x06Config\x12\x12\
    \n\x04Data\x18\x02\x20\x01(\x0cR\x04Data\x12\x1a\n\x08ProverId\x18\x03\
    \x20\x01(\x0cR\x08ProverId\x12\x1a\n\x08SectorId\x18\x04\x20\x01(\x04R\
    \x08SectorId\x12)\n\x06Pieces\x18\x06\x20\x03(\x0b2\x11.FilPieceMetadata\
    R\x06Pieces\x12\"\n\x0cPieceLengths\x18\x05\x20\x03(\x04R\x0cPieceLength\
    s\"\x87\x01\n\x15FilGetSoonSealRequest\x122\n\x14SealAllStagedSectors\
    \x18\x01\x20\x01(\x08R\x14SealAllStagedSectors\x12\x1a\n\x08ProverId\x18\
    \x02\x20\x01(\x0cR\x08ProverId\x12\x1e\n\nSectorSize\x18\x03\x20\x01(\
    \x04R\nSectorSize\"\x87\x01\n\x16FilGetSoonSealResponse\x12%\n\x05Seals\
    \x18\x01\x20\x03(\x0b2\x0f.FilSealRequestR\x05Seals\x12*\n\x06Status\x18\
    \x02\x20\x01(\x0e2\x12.FilResponseStatusR\x06Status\x12\x1a\n\x08ErrorMs\
    g\x18\x03\x20\x01(\tR\x08ErrorMsg\"J\n\x16FilSealCallBackRequest\x120\n\
    \nSealResult\x18\x01\x20\x01(\x0b2\x10.FilSealResponseR\nSealResult\"d\n\
    \x0eFilPoRepConfig\x12\x1e\n\nSectorSize\x18\x01\x20\x01(\x04R\nSectorSi\
    ze\x122\n\x14PoRepProofPartitions\x18\x02\x20\x01(\x04R\x14PoRepProofPar\
    titions\"\xd1\x01\n\x14FilVerifySealRequest\x12'\n\x06Config\x18\x01\x20\
    \x01(\x0b2\x0f.FilPoRepConfigR\x06Config\x12\x14\n\x05CommR\x18\x02\x20\
    \x01(\x0cR\x05CommR\x12\x14\n\x05CommD\x18\x03\x20\x01(\x0cR\x05CommD\
    \x12\x16\n\x06CommRs\x18\x04\x20\x01(\x0cR\x06CommRs\x12\x1a\n\x08Prover\
    Id\x18\x05\x20\x01(\x0cR\x08ProverId\x12\x1a\n\x08SectorId\x18\x06\x20\
    \x01(\x04R\x08SectorId\x12\x14\n\x05Proof\x18\x07\x20\x01(\x0cR\x05Proof\
    \"\xb3\x01\n\x15FilVerifyPieceRequest\x120\n\x13PieceInclusionProof\x18\
    \x01\x20\x01(\x0cR\x13PieceInclusionProof\x12\x14\n\x05CommD\x18\x02\x20\
    \x01(\x0cR\x05CommD\x12\x14\n\x05CommP\x18\x03\x20\x01(\x0cR\x05CommP\
    \x12\x1c\n\tPieceSize\x18\x04\x20\x01(\x04R\tPieceSize\x12\x1e\n\nSector\
    Size\x18\x05\x20\x01(\x04R\nSectorSize\"a\n\rFilPoStConfig\x12\x1e\n\nSe\
    ctorSize\x18\x01\x20\x01(\x04R\nSectorSize\x120\n\x13PoStProofPartitions\
    \x18\x02\x20\x01(\x04R\x13PoStProofPartitions\"\xf7\x01\n\x14FilVerifyPo\
    StRequest\x12&\n\x06Config\x18\x01\x20\x01(\x0b2\x0e.FilPoStConfigR\x06C\
    onfig\x12\x1d\n\nsector_ids\x18\x02\x20\x03(\x04R\tsectorIds\x12*\n\x11f\
    aulty_sector_ids\x18\x03\x20\x03(\x04R\x0ffaultySectorIds\x12\x16\n\x06C\
    ommRs\x18\x04\x20\x03(\x0cR\x06CommRs\x12$\n\rChallengeSeed\x18\x05\x20\
    \x01(\x0cR\rChallengeSeed\x12\x16\n\x06Proofs\x18\x06\x20\x01(\x0cR\x06P\
    roofs\x12\x16\n\x06Faults\x18\x07\x20\x03(\x04R\x06Faults\"~\n\x20FilGen\
    eratePieceCommitentRequest\x12,\n\x11UnpaddedPieceData\x18\x01\x20\x01(\
    \x0cR\x11UnpaddedPieceData\x12,\n\x11UnpaddedPieceSize\x18\x02\x20\x01(\
    \x04R\x11UnpaddedPieceSizeB\x18\xe0\xa7\x08\x01\xc8\xa6\x08\x01\xe0\xa6\
    \x08\x01\x80\xa8\x08\x01\xb0\xa8\x08\x01\xd8\xa6\x08\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
